---
title: 设计模式总结
date: 2018-11-26 14:23:05
tags:
categories: program
---

# 定义

在[软件工程](https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B)中，**设计模式**（design pattern）是对[软件设计](https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88)中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由[埃里希·伽玛](https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA)（Erich Gamma）等人在1990年代从[建筑设计](https://zh.wikipedia.org/wiki/%E5%BB%BA%E7%AD%91%E8%AE%BE%E8%AE%A1)领域引入到[计算机科学](https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)的。

# 作用

优化代码的修改和版本迭代。以增强软件设计面对并适应变化的能力。使得在软件需求不断变化的时候，仍然能够更加高效地在编程代码中实现。

增加代码的重用性和可维护性。使得在增加或者修改新功能的时候，可以不用大幅度修改原有的代码，而是可以复用以前的老代码，或者仅仅是简单的修改一些参数和配置。

# 起源

在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。

# 面向对象设计原则

四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。

**对接口编程而不是对实现编程。**

**优先使用对象组合而不是继承。**

# 设计模式6大原则

## 1、开闭原则（Open Close Principle）

开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

## 2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

## 3、依赖倒转原则（Dependence Inversion Principle）

这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。

## 4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。

## 5、迪米特法则，又称最少知道原则（Demeter Principle）

最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。

## 6、合成复用原则（Composite Reuse Principle）

合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。

# 设计模式分类

根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）中所提到的：总共有 **23 种设计模式**。

这些模式可以分为三大类：

- 创建型模式（Creational Patterns）
- 结构型模式（Structural Patterns）
- 行为型模式（Behavioral Patterns）



# 创建型模式（5种）

这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

- 工厂模式（Factory Pattern）
- 抽象工厂模式（Abstract Factory Pattern）
- 单例模式（Singleton Pattern）
- 建造者模式（Builder Pattern）
- 原型模式（Prototype Pattern）

## 工厂模式

原始的对象创建是通过new关键词实现，将类的创建过程交给用户自己操作。通过工厂模式，将类的创建过程交给另一个工厂类（FactoryClass），通过调用该工厂类的某个方法来完成。他的典型用途有“单例模式”。

## 抽象工厂模式

上述的工厂类本身又是由另一个超级工厂创建出来的。主要是为了对创建的类进行更细化的分类。

## 单例模式

一个类只有一个实例。主要应用在某些只需要一个类就能完成的功能。例如数据库的连接句柄，可以共用。（但是共用的时候要注意线程安全问题）。在多线程环境，也要注意加锁，防止由于两个线程读取到的内部存储实例的变量状态不一致，导致单例工厂方法错误的创建多个线程。在Java多线程环境下有synchronized同步锁。

## 建造者模式

在一个类中，通过一系列的集合对象，将多个类的实例对象存储到一个成员中。例如电商网站的订单系统，就是将多个商品实体类的实例对象存储到一个订单对象中，然后可以进行下单方法，计算总价方法等等操作。

## 原型模式

将一个已经实例化的对象直接克隆出另一个一模一样的对象实例。通过这种方法来创建对象开销比较小。因为只需要拷贝成员（深拷贝和浅拷贝），无需进行开销较大的构造方法执行操作。例如老版本ECMAScript（JavaScript）的原型创建对象。



# 结构型模式（8种）

这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。

- 适配器模式（Adapter Pattern）
- 桥接模式（Bridge Pattern）
- 过滤器模式（Filter、Criteria Pattern）
- 组合模式（Composite Pattern）
- 装饰器模式（Decorator Pattern）
- 外观模式（Facade Pattern）
- 享元模式（Flyweight Pattern）
- 代理模式（Proxy Pattern）

## 适配器模式

将一个类的接口通过一个适配器类转换成另一个借口。例如PHP PDO就是一个适配器类，将MySQL和Oracle数据库不同的操作接口适配成统一的PDO操作接口。

## 桥接模式

某个类的方法需要调用另一个类的方法，那么预留一个参数为该类的类型。调用的时候根据业务逻辑的不同，调用不同的类。这种方法将两个类桥接，实现功能的灵活调用。

## 过滤器模式

通过使用不同的标准（Criteria）和它们的结合来过滤某些对象。例如电商网站搜索功能中的只显示包邮信息，只显示价格区间在xxx-xxx之间的商品对象等等。

## 组合模式

在某个对象的成员里面再组合另一个对象，然后调用的时候可以通过这个成员来调用另一个被组合进该对象的对象。例如Windows目录树，电商网站的商品分类目录等等。

## 装饰器模式

通过在该类外部再包装一个类，这个类给原始类新增了一些功能，但是并不改变原有类的行为。就像装饰一样将新的行为方法增加上去。例如Python的装饰器

## 外观模式

系统原有类的调用比较复杂，现在通过一个统一的外观门面类（Facade）来封装原本复杂的操作类。例如PHP的Laravel框架中的Redis缓存和数据库操作，原本需要先连接句柄，设置一些连接参数，然后在调用各种方法才能完成的操作，通过一个Cache门面类的set，get静态方法直接调用，简化了对原有类的方法调用。

## 享元模式

系统中可能会实例化大量的类，这些实例化对象的属性可能都不一样，而某些对象实例可能会重用，因此在第一次创建的时候将他们缓存起来，下次如果还需要调用属性匹配的对象实例，先判断是否有缓存，有就可以直接取出，没有则先创建，然后写缓存，然后再返回。类似于WEB开发中利用Redis做MySQL数据库缓存。

## 代理模式

某些类的某些成员或者方法需要进行一些校验，或者过滤操作。那么不能让开发者直接访问这个类，需要另外写一个代理类，通过这个代理类去操作原始类。而这个代理类的内部有鉴权，校验，过滤等操作。

 

# 行为型模式（12种）

这些设计模式特别关注对象之间的通信。

- 责任链模式（Chain of Responsibility Pattern）
- 命令模式（Command Pattern）
- 解释器模式（Interpreter Pattern）
- 迭代器模式（Iterator Pattern）
- 中介者模式（Mediator Pattern）
- 备忘录模式（Memento Pattern）
- 观察者模式（Observer Pattern）
- 状态模式（State Pattern）
- 空对象模式（Null Object Pattern）
- 策略模式（Strategy Pattern）
- 模板模式（Template Pattern）
- 访问者模式（Visitor Pattern）

## 责任链模式

行为设计模式，为请求设置一系列的接受者，这些接受者依次接受请求，并且按照链往下传递。类似于Java JSP的filter，Struts的拦截器，Laravel的中间件。Nginx中也有用到类似技术。

## 命令模式

将某些操作封装成一个类，对外只暴露execute方法。另一个专门负责执行的类，只负责调用这些类的execute方法，至于具体执行什么操作，由传入的命令类来决定。例如按钮可以绑定一个点击事件，至于点击之后执行什么操作，由绑定的命令类来决定。

## 解释器模式

定义一个语言和一个解释器类。这个解释器类解析语句，执行相应的操作。对于某些问题发生的频率比较高，那么值得编写一个解释器类来解释语句从而解决问题。例如SQL，正则表达式。

## 迭代器模式

某些类内部会存储一个聚合对象（包含多个成员的一系列对象，例如线性表），不同的聚合对象存储方式，遍历他的底层操作可能不一样。但是对外暴露一个迭代器方法，使得对于任何聚合对象，都可以使用统一的迭代器操作来遍历。例如JAVA的iterator接口具有hasNext，next方法。

## 中介者模式

当多个类耦合在一起，形成了网状的耦合，可以将两个类的功能分离。通过在其中一个类中，直接调用另一个类，调用时传入目标对象，实现解耦合，例如PHP框架中，返回HTML或者XML或者JSON，就让控制器调用不同的response对象。

## 备忘录模式

将一个类当前的状态全部保存，在以后需要的时候再调用。具体场景有编辑草稿功能。代码中的应用有PHP的serialize序列化操作。（但是要注意的是，代码中的序列化保存的只是类的属性，而不是行为方法，如果需要调用行为，还需要原始类代码在运行时上下文中）。

## 观察者模式

某个对象的属性修改，将通过一个广播方法告知其他对象，让其他对象观察到这个这个状态的改变，从而作出响应。在Yii框架中的事件系统就有类似的行为。例如买家发起退货请求，同时要将这个请求发送给物流商，卖家以及淘宝官方，还有后台的日志，大数据统计系统等等。

## 状态模式

一个类的内部状态修改之后，将返回不同的类。例如淘宝订单状态变成退货状态之后，需要改用退货类，而不是原始的已购买宝贝类。

## 空对象模式

某些情况下，某些对象可能为null，此时这类空对象需要一个默认行为。例如歌曲播放APP中如果一个歌曲的歌手为空，那么应该显示为“佚名”，显示佚名这个操作就是空对象的一个默认行为。

## 策略模式

某些对数据结构的操作接口相同，只是内部的算法不一样。因此将这一系列的算法封装成单独的策略类。在不同的行为驱动下，调用不同的算法策略。例如某个场景，我们已知整个数列大致有序，现在希望把它排序成整体有序，我们就可以使用最优情况下时间复杂度低的插入排序策略。如果我们对排序空间没有要求，但是对速度要求高，我们可以使用归并排序策略等等。

## 模版模式

某个算法中的小步骤都是相同的，只是外部的一些调用不同。因此可以把这个算法封装成一个模板类（与C++中的模板概念无关），这个模板类内部有一些步骤相同的方法代码。而开发者具体实现的时候，不需要（也不能修改，因为模板类会把这些方法定义为final修饰）修改和关心这些相同的小步骤的实现细节，只需要调用就好。例如排序算法中通常都有交换（swap）这个操作，因此可以将所有排序算法都封装一个模板类，模板类内定义一个被final修饰的swap方法。开发者在具体实现某个排序算法的时候可以直接继承这个模板类，然后调用swap算法即可。不需要再每个算法的具体实现类中手动实现一遍swap算法。

某些算法的宏观调用是一样的，只是内部的细节操作不一样。因此将这些宏观调用方法封装成一个模板类。在具体实现的时候，只需要继承模板类，然后实现底层的方法。例如一个视频播放插件，对于每个视频来说都有播放，暂停等操作，也就是这个类的execute方法中都会先后调用play()和pause()方法，但是不同的视频格式，对于play()这个操作来说，他具体的解码算法也不一样，所以需要底层开发者具体实现不同的play()方法。但是上层调用者只需要调用execute即可，无需关心底层的play()方法具体是什么算法。

## 访问者模式

定义一系列的访问者对象。开发者调用不同类型的访问者对象，受访者对象将执行不同的行为方法。访问者模式主要利用了代码中的重载override特性。例如支付宝收银台外，部调用的都是buy()方法，只是传入的访问者参数对象类型不一样。选择银行卡支付，那么访问者就是银行卡类，也就是buy(BankCard)，选择支付宝余额支付，访问者就是支付宝余额，也就是buy(AlipayBalance)。然后每个不同的访问者类型，将调用不同的后端逻辑，例如BankCard访问者将调用银行卡扣款的业务逻辑，支付宝余额就调用支付宝余额的扣款逻辑。

 

 

 