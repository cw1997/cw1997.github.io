---
title: 数据库系统（上）：模型与语言
date: 2020-07-05 03:47:03
tags: database
categories: database
---

# Table

表

具有表名，表标题，表内容

表内容有行（元组，记录）

列（字段，属性，数据项，column，field，attribute）

# Database

数据库

相互之间有关联关系的Table集合

数据库的工作环境有DB，DBMS，DBAP，DBA几种

DBAP就是平时的数据库应用程序，例如一个网站，一个ERP，CRM程序

# 数据库的几大功能

## DDL（Data Definition Language）

用户使用它建立表格式

## DML（Data Manipulation Language）

进行CRUD增删改查操作

读是Retrieve

## DCL（Data Control Language）

数据控制语言，对用户进行授权等操作，例如grant语句

## 数据库维护

转储，恢复备份，重组等等

# 数据库系统标准结构

## 数据库的分层抽象

DBMS管理数据分为三个层次

### External Level = User Level 

外部层次，业务层次

某一用户可以看到和处理的数据，全局数据中的某一部分

用户可以看见的数据，通常是从DBAP上面看到的数据，之所以有这个层次，是因为数据库里面还有一些关联表或者底层数据结构（例如枚举在数据库里面存储的是一个数字，还有一些键）不太适合给普通用户使用和阅读，所以抽象出这个层次，方便不懂数据库的用户进行数据的操作

### Conceptual Level = Logic Level

概念层次，全局层次，逻辑层次

从全局的角度理解和管理数据，包含对应的关联约束，例如多对多的关联表

### Internal Level = Physical Level

存储在介质上的数据，包含存储路径，存储方式，索引方式

通常是数据库最底层落到硬盘上面的文件内容。在MSSQL中是mdf，Access中是mdb等，他们是按照C语言中的某些数据结构进行存储，例如索引按照Hash或者B+Tree的数据结构存储到硬盘。

## 数据视图与模式

### 模式（Schema）

对数据库中的数据所进行的一种结构性描述

所观察到数据的结构信息

#### 外模式（External Schema）

某一用户能够看到与处理的数据的结构描述

#### 概念模式（Conceptual Schema）

体现数据之间的内在本质联系

#### 内模式（Internal Schema）

存储在介质上的数据的结构描述

### 视图（View） / 数据（Data）

某一种表现形式下表现出来的数据库中的数据是视图

数据是数据库中所有数据的统称，视图是从所有数据中挑选一中表现形式表现出来的部分数据

## 三级模式两层映像

#### E-C Mapping

DBAP通常是做这个工作的

#### C-I Mapping

DB通常是做这个工作的

三级模式分层有个好处就是保证物理数据和逻辑数据的独立性，例如修改其中一层，只要保证mapping正常工作，那么另外一层可以不做修改的情况下继续工作

例如MySQL到Maria DB就是保证了E-C Mapping可以不发生任何变化

## 三大经典数据模型

关系模型：表

层次模型：树

网状模型：图

# 关系模型

关系模型是大多数商业化数据库系统仍然使用的数据模型

它是从表以及表的处理方式抽象出来，是对传统表以及操作进行数学化严格定义基础上，引入集合理论与逻辑学理论

一个Relation就是一个Table

## 关系模型由三个部分组成

- 描述DB各种数据的基本结构形式
- 描述Table与Table之间所有可能发生的各种操作（关系运算）
- 描述这些操作应该遵循的约束条件（完整性约束）

## 三个要素

- 基本结构：Relation/Table
- 基本操作：Relation Operator

基本操作：并（Union），差（Difference），广义乘积（Product），选择（Selection），投影（Projection）

扩展操作：交（Intersection），连接（Join），除（Division）

- 完整性约束：实体完整性，参照完整性，用户自定义完整性（域完整性）

关系运算

关系代数和关系演算，关系演算：元组验算，域验算

# 表的严格定义——关系

## 域（列的取值范围）

- 一组值的集合，这组值具有相同的数据类型，例如整数的集合，字符串的集合，全体学生集合

集合中元素的个数成为域的基数（Cardinality）

## 笛卡尔积（Cartesian Product）

对一组域D1，D2，。。。，Dn做笛卡尔积运算，可以求出多个域能够组合出来的所有可能的元组

笛卡尔积的每个元素 $$ (d_1, d_2, ... , d_n) $$ 成为一个n元组（n-tuple）

笛卡尔积的基数就是每个域的基数相乘

## 关系（Relation）

接着上面的笛卡尔积来深入理解

要明白一个道理：对一组域求笛卡尔积，所得到的元组里面并不一定所有元组都有意义，例如（男人，女人，子女）这三个域做笛卡尔积，里面会出现张三的父亲和李四的母亲和王五这个儿童所组成的一个元组，而他们三个人其实并没有任何血缘关系也不是属于同一个家庭。

而只有真正男人女人子女能够组成家庭的那个元组才有意义。其中这个有意义的元组组合我们称为一个关系。

对于一个关系的列，我们要重新给它起一个名字，叫做列名（属性名），里面的值叫做列值，列值来自一个域。

### 关系模式的描述

$$
R(A_1:D_1, A_2:D_2, ..., A_n:D_n)
$$

上面成为关系模式（Schema）或者表标题（head）

R是关系名字，A_i 是属性，D_i 是属性所对应的域，n是关系的度或者目（degree，关系元组的数目成为关系的基数（Cardinality））

一个实际的关系模式例子
$$
家庭（丈夫：男人，妻子：女人，子女：儿童）
$$
在数据库中域通常就是数据类型

例如
$$
Student(Sid\ char(8), Sname\ char(10))
$$


## 关系模式与关系

- 同一个关系模式下可能有很多关系
- 关系模式是关系的结构，关系是关系模式在某一时刻的数据
- 关系模式是稳定的，关系是某一时刻的值，它可能随着时间变化（因为数据会有增删改查）

### 关系

列是同质的，也就是列中的每个量都是来自同一个域，是同一个类型的数据

不同的列可以来自同一个域，例如一个家庭关系里面的丈夫和爷爷都来自男人这个域

关系是具有行列位置的互换性，也就是行和列是靠名字和值来区分，不靠顺序区分

### 表和关系的区别

理论上关系的任意两个元组不能完全相同（集合内不能有相同的两个元素），现实中的Table可能并不完全遵循关系的特性，这也是关系和表的区别。

属性不可再分：又被称为关系第一范式。例如姓名有姓氏和名字（中国和美国都有），那么就应该把Full Name这个列拆分成First Name和Last Name或者合并成一个列

## 候选码/候选键（Candidate Key）

例如学号就是学生中的候选码

选课关系中，学号和课号可以唯一确定一个选课关系

关系当中并不一定只有一个候选码，例如雇员的工号是一个候选码，但是雇员的手机号也是一个候选码（因为不可能有两个员工的手机号一模一样）

## 主键（Primary Key）

主码是从多个候选码中选定一个作为主码

选定主码需要深思熟虑，例如上面的雇员关系中，通常不会选择用手机号作为主码，因为员工可能会更换手机号，同一个手机号也有可能在更换之后被别的员工使用，也有可能一个员工有多个手机号。所以通常这种情况下我们另外定义一个工号（通常是自增ID）作为主码

## 主属性

包含在任何一个候选码中的属性被称作主属性，也就是说在联合主键中，每个单独的列都是一个主属性。而其他属性是非主属性

简单的情况下主键只有一个列，所以主键列就是主属性

极端情况下所有属性都构成这个关系的候选码，成为全码（All-Key），全码通常在多对多关联表中出现。

## 外键（Foreign Key）

关系R中的一个属性组它不是R的候选码，但它与另外一个关系S的候选码相对应，则称这个属性组为R的外键

例如合同关系中标识这个合同的甲方客户是谁，就需要通过客户表的主键来建立连接，因此就需要在合同关系中记录客户表主键，这个合同关系中的客户表主键就是一个外键、



# 关系模型的完整性约束

## 实体完整性

关系主码属性值不能为空

空值是不知道或者无意义的值

关系中元组对应到现实世界相互之间可区分的各地，这些个体是通过主码唯一标识。如果主码为空则出现不可标识的个体，这是不容许的。

非主属性出现空值需要特殊处理：例如成绩表中，有个学生没有成绩，那么统计全班平均分到底怎么考虑呢，所以遇到空值需要特殊处理。

## 参照完整性

外键可以取空值，但是如果不取空值的话，那么外键必须是参照表中的其中一个主码

## 用户定义完整性（域完整性）

也就是取值范围的约束，例如生理性别通常只有男女，姓氏通常最大只有五个字符，通常不会有其他情况。



不符合完整性约束的表通常无法存储进数据库中



# 关系代数

集合操作：并，交，差，笛卡尔积

纯关系操作：投影，选择，连接，除

## 并相容性

参与运算的两个关系以及相关属性之间有一定的相对性，可比性或者意义关联性

关系R与关系S存在相容性，当且仅当

- R和S的属性数目相同
- 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同

## 基本运算

### 并运算（Union）

将两个关系的元组合并成一个关系，在合并时去掉重复元素

关系R和S并相容，则关系R和S的并运算结果也是一个关系，

### 差运算（Difference）

R和S并相容，则R与S的差运算也是一个关系，它是出现在关系R但不出现在关系S的元组

### 广义笛卡尔积（Cartesian Product）

把关系R和关系S的元组进行所有可能的拼接（水平连接Join）

它是各种连接运算的基础

广义笛卡尔积是满足交换律的，因为行列具有互换等价性

### 选择运算（Selection）

从关系R中选择满足给定条件Condition的元组组成

### 投影运算（Project）

投影运算结果是从关系R中选出属性包含在A中的列

投影运算就是选择某些类作为一个新关系

## 扩展运算

### 交（Intersection）

R和S并相容，则关系R和S的运算结果是同时出现在关系R和S的元组构成

交运算可以用差运算实现
$$
R交S=R-(R-S)=S-(S-R)
$$

## 连接操作（Join）

给定一个连接条件，在关系R和S的笛卡尔积中，选取R中属性A与S中属性B满足条件的元组构成

也叫theta连接操作

自连接操作也就是自己跟自己做连接，在连接的时候需要做一个更名操作

## 等值连接操作（Equi-Join）

给定关系R和S，结果由R和S的笛卡尔积中选取R中属性A和S中属性B上值相等的元组构成

## 自然连接（Natural-Join）

自然连接是没有条件，所以需要有一个默认的规则

这个规则就是相同的属性组以及对应属性组上面的值相等

关系R和S的笛卡尔积中选取相同的属性组B上值相等的元组构成

## 除运算（Division）

R和S的结果属性集合是R属性集合去掉S当中的属性集合

然后新的元组必须满足的条件是S里面的元组必须在R的元组中

计算方法是首先寻找R中所有对应列和S的所有属性相等的元组，然后再从R中移除所有S属性集合

##  外连接（Outer-Join）

定义两个关系R和S连接时，如果R或者S在对方关系中找不到关系，就要假设和对方关系的一个空元组进行连接，放置在结果关系中

外连接=自然连接+失配元组（与空元组形成的连接）

分为左外和右外连接和全外联接



# 关系演算

以数理逻辑中的谓词演算为基础

关系元组演算：以元组变量作为维持变量的基本对象

关系域验算：以域变量作为维持变量的基本对象

 基本公式形式
$$
\{t|P(t)\}
$$
使得谓词P为真的元组t的集合

- t是元组变量
-  $ t\in r $ 表示元组t在关系r中
- t[A]表示元组t的分量，也就是t在属性A上的值
- P是与谓词逻辑相似的公司，P(t)表示以元组t为变量的公式

P(t)的递归构造

首先有三种形式的原子公式
$$
s\in R \\
s[A] \theta c \\
s[A] \theta u[B]
$$

##  关系元组演算公式

t是关系R中的一个元组，表示
$$
t \in R
$$
例如，表示元组都是来自学生关系
$$
\{ t | t \in Student \}
$$




元组分量s[A]与常量c之间满足比较关系 \theta
$$
s[A] \theta c
$$
比较运算符有大于小于，大于等于和小于等于，等于和不等于

例如
$$
\{ t|t \in R \cap t[Sage] <= 19 \cap t[Sname]='张山' \}
$$


A和B是某些关系的属性，s[A] s[B] 为元组分量，他们之间满足比较关系 \theta
$$
s[A] \theta s[B]
$$
例如
$$
\{ t | t \in Student \cap \exist (u \in Student) (t[Sage] > u[Sage])  \}
$$


构造 P(t) 还有两个运算符：存在和任意

存在表示只有一个就为真，任意是必须所有都为真

## 域演算

域变量的组合，满足后面的公式

基本形式
$$
\{ <x_1, x_2, ..., x_n> | P(x_1, x_2, ..., x_n) \}
$$
x_i 代表域变量或者常量， P为以x_i为变量的公式



## 域演算语言QBE（Query By Example）

不需要写复杂公式，只需要填表即可

QBE有四个部分构成

- 关系名：待查询的关系名
- 属性名：对应关系名区关系的所有属性名
- 操作命令：操作命令（Print，Delete，Insert，Update）
- 查询条件：查询条件（表的body区域都是查询条件）

通过填表的方式表达增删改查的操作

## 关系演算安全性

不产生无线关系和无穷验证的运算

关系代数是一种集合运算，是安全的。因为集合本身是优先的，有限元素集合的有限次运算仍然是有限的。

关系演算不一定安全

例如域演算可能会有某个条件会返回无穷多的关系

真假验证的验证存在或者任意有可能会出现需要验证所有元素的情况，验证所有元素就可能造成无穷

因此需要对关系演算施加约束条件，也就是任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性

### 安全约束有限集合DOM

DOM是一个有限集合，每个符号要么是 \phi 中明显出现的符号，要么是出现在 \phi 中的某个关系R的某个元组的分量

DOM约束 \phi 中一些谓词的计算范围，它不必是最小集合



- t满足\phi t的每个分量就是DOM(\phi)的一个成员



## 等价关系

关系代数 安全的元组演算表达式 安全的域演算表达式

数据库语言能够等价实现这三种关系运算的操作，则说明该语言是完备的



# SQL

## DDL

Create, Alter, Drop

## DML

Insert, Delete, Update

## DCL

Grant, Revoke

