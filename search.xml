<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>微分方程</title>
      <link href="/2018/12/07/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
      <url>/2018/12/07/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>表示位子函数、未知函数的导数与自变量关系之间的方程就是<strong>微分方程</strong></p><p>n阶微分方程的形式为<br>$$<br>F(x,y,y’,y’’,…,y^{(n)}) = 0 \\<br>y^{(n)} = F(x,y,y’,y’’,…,y^{(n-1)})<br>$$</p><h1 id="微分方程的阶"><a href="#微分方程的阶" class="headerlink" title="微分方程的阶"></a>微分方程的阶</h1><p>微分方程中所出现的未知函数的最高阶导数的阶数</p><h1 id="微分方程的解"><a href="#微分方程的解" class="headerlink" title="微分方程的解"></a>微分方程的解</h1><h2 id="解"><a href="#解" class="headerlink" title="解"></a>解</h2><p>设函数在y=g(x)在区间I上有n阶连续导数，如果在区间I上有<br>$$<br>F[x,g(x),g’(x),g’’(x),…,g^{n(x)}] = 0<br>$$<br>则函数y=g(x)就叫做微分方程在区间I上的解</p><h2 id="通解"><a href="#通解" class="headerlink" title="通解"></a>通解</h2><p>如果微分方程的解中含有相互独立的任意常数，且任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解 </p><h2 id="特解"><a href="#特解" class="headerlink" title="特解"></a>特解</h2><p>确定了通解中的任意常数以后，就得到微分方程的特解</p><h2 id="初值条件"><a href="#初值条件" class="headerlink" title="初值条件"></a>初值条件</h2><p>用来确定通解中的任意常数的附加条件称为<strong>初值条件</strong></p><h1 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h1><p>通常一个微分方程通解对应的是在一个二维平面内曲率或者变化率相同，但是高度不同的曲线。求通解就是根据题目中的已知条件求得这个变化率是多少。求具体高度，就是根据初值条件求特解。</p><h1 id="可分离变量的微分方程"><a href="#可分离变量的微分方程" class="headerlink" title="可分离变量的微分方程"></a>可分离变量的微分方程</h1><p>如果一个一阶微分方程能写成<br>$$<br>g(y)dy = f(x)dx<br>$$<br>则原方程就是<strong>可分离变量</strong>的微分方程</p><p>假设方程中的 g(y) 和 f(x) 是连续的，设 y=h(x) 是原方程的解，导入原方程得到<br>$$<br>g[h(x)]h’(x)dx = f(x)dx \\<br>\int g[h(x)]h’(x)dx = \int f(x)dx<br>$$<br>通过 g(y) 引入变量 y 得到<br>$$<br>\int g(y)dy = \int f(x)dx<br>$$<br>设 G(y) 及 F(x) 依次为 g(y) 及 f(x) 的原函数，于是就有<br>$$<br>G(y) = F(x) + C<br>$$<br>反之，如果 y=h(x) 是 G(y) = F(x) + C 确定的隐函数（可以通过y=h(x)确定C为多少，也就是确定了这个隐函数的方程），则在 g(y)≠0 的条件下<br>$$<br>h’(x) = \frac{F’(x)}{G’(y)} = \frac{f(x)}{g(y)}<br>$$<br>这表示，函数 y=h(x) 满足方程 g(y)dy = f(x)dx </p><p>则隐式通解为<br>$$<br>G(y) = F(x) + C<br>$$</p><h1 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h1><p>类似于<br>$$<br>\frac{dy}{dx} = h(\frac{y}{x})<br>$$<br>的一阶微分方程称为<strong>其次微分方程</strong>，简称<strong>齐次方程</strong></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>对于<br>$$<br>\frac{dy}{dx} = h(\frac{y}{x})<br>$$<br>令 $ u = \frac{y}{x}$ 则有 $y = ux$ ，根据导数的乘法运算法则有<br>$$<br>y’(x) = \frac{dy}{dx} , \frac{dy}{dx} = ux’ + u’x = u + x\frac{du}{dx}<br>$$<br> 带入原方程之后得到<br>$$<br>u + x\frac{du}{dx} = h(u), 移项得 x\frac{du}{dx} = h(u) - u<br>$$<br>两边同时积分得<br>$$<br>\int \frac{du}{h(u) - u} = \frac{dx}{x}<br>$$<br>求出积分之后再用 $\frac{y}{x}$ 代替 u </p><p>最终解出该齐次微分方程</p><h1 id="可化为齐次的方程"><a href="#可化为齐次的方程" class="headerlink" title="可化为齐次的方程"></a>可化为齐次的方程</h1><p>$$<br>\frac{dy}{dx} = \frac{ax+by+c}{a_1x+b_1y+c_1}<br>$$</p><p>当 $c=c1=0$ 时，是其次的，否则不是其次的（在没有c和c1常数项的时候，可以通过两边同时除以x来转换成齐次方程，有则无法转换）</p><p>在非齐次的情形下，我们可以令 $x=X+h$，$y=Y+k$，其中 h 及 k 是待定的常数，于是 dx=dX，dy=dY<br>$$<br>\frac{dY}{dX} = \frac{a(X+h)+b(Y+k)+c}{a_1(X+h)+b_1(Y+k)+c_1} = \frac{aX+bY+ah+bk+c}{a_1X+b_1Y+a_1h+b_1k+c_1}<br>$$<br>如果我们精心选择 h 和 k 这两个待定常数，可以令 $ah+bk+c=0,a_1h+b_1k+c_1=0$</p><p>如果 $\frac{a_1}{a} ≠ \frac{b_1}{b}$ 则可以唯一确定h，k这两个数，使他们满足上述方程组</p><p>求出这个齐次方程的通解之后，在用 $x-h$ 代替X， $y-k$ 代替 Y ，解得原方程的通解。</p><p>如果 $\frac{a_1}{a} = \frac{b_1}{b}$ 时，令 $\frac{a_1}{a} = \frac{b_1}{b} = \lambda $ ，原方程可以写成<br>$$<br>\frac{dy}{dx} = \frac{ax+by+c}{\lambda (ax+by)+c_1}<br>$$<br>令 $v=ax+by$  ，则 $\frac{dv}{dx} = a+b \frac{dy}{dx}$ ，推导出 $\frac{1}{b}(\frac{dv}{dx}-a) = \frac{v+c}{\lambda v + c_1}$ </p><p>这样就成功分离了变量，化为了可分离变量的微分方程</p><p>实际上，对于任何14式所代表的方程都可以这样转化然后求解</p><h1 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h1><p>$$<br>y’=\frac{dy}{dx}=Q(x)-P(x)y<br>$$</p><p>移项之后<br>$$<br>\frac{dy}{dx}+P(x)y=Q(x)<br>$$<br>形如上述的方程称为 <strong>一阶线性微分方程</strong> </p><h2 id="齐次与非齐次"><a href="#齐次与非齐次" class="headerlink" title="齐次与非齐次"></a>齐次与非齐次</h2><p>如果 $Q(x) = 0$ 则方程是<strong>齐次方程</strong></p><p>如果 $Q(x) ≠ 0$ 则方程是<strong>非齐次方程</strong></p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>$$<br>\frac{dy}{dx}+P(x)y=0,\frac{dy}{dx}=-P(x)y=h(\frac{y}{x})<br>$$</p><h2 id="对应于非齐次线性方程的齐次线性方程"><a href="#对应于非齐次线性方程的齐次线性方程" class="headerlink" title="对应于非齐次线性方程的齐次线性方程"></a>对应于非齐次线性方程的齐次线性方程</h2><p>对应于非齐次线性方程，把右边的Q(x) 视为0之后得到的新方程，视为是对应于非齐次线性方程的齐次线性方程，是可分离变量的，因为我们可以将上式中的 <code>y</code> 和 <code>-P(x)</code> 移项得到<br>$$<br>\frac{dy}{dx}=-P(x)y,\frac{dy}{y} = -P(x)dx<br>$$<br>对这个式子两端同时积分后得到<br>$$<br>ln|y| = - \int P(x)dx +C_1<br>$$<br>把 y 解出来得到（可以将 $e^C$ 直接视为一个常数C）<br>$$<br>y = e^{-P(x)dx + C_1} = e^{-P(x)dx} e^{C_1} = Ce^{-P(x)dx}<br>$$</p><h2 id="常数易变法"><a href="#常数易变法" class="headerlink" title="常数易变法"></a>常数易变法</h2><p>对于一阶线性微分方程 $\frac{dy}{dx}+P(x)y=Q(x)$ 来说，我们可以把上述解出来的 y 中的常数，用 u(x) 来替代，也就是将常数异变为 u(x) ，这也就是标题 <strong>常数易变法</strong> 的来历。</p><p>易变之后得到<br>$$<br>y = u(x)e^{-P(x)dx}<br>$$<br>两边同时求导，根据导数的乘法运算法以及复合函数求导法则得到<br>$$<br>y’ = \frac{dy}{dx} = u’e^{-P(x)dx} + u(-P(x)e^{-P(x)dx})<br>$$<br>把 y 和 y’ 带入原方程后化简得到<br>$$<br>u’(x) = Q(x)e^{P(x)dx}<br>$$<br>积分求得原函数为<br>$$<br>u = \int Q(x)e^{P(x)dx}dx+C<br>$$<br>带入把 u 带入原方程中替换常数项 C 得到<br>$$<br>y = e^{-P(x)dx}(\int Q(x)e^{P(x)dx}dx+C) = Ce^{-P(x)dx} + e^{-P(x)dx}\int Q(x)e^{P(x)dx}dx<br>$$<br>对于这个式子<br>$$<br>y = Ce^{-P(x)dx} + e^{-P(x)dx}\int Q(x)e^{P(x)dx}dx<br>$$<br>左边为齐次线性方程的通解，右边为非齐次线性方程的一个特解</p><h2 id="伯努利方程"><a href="#伯努利方程" class="headerlink" title="伯努利方程"></a>伯努利方程</h2><p>$$<br>\frac{dy}{dx}+P(x)y=Q(x)y^n<br>$$</p><p>这样的方程就是<strong>伯努利方程</strong></p><p>当n=0或1时，这是线性微分方程，否则就是非线性的。</p><p>但是可以通过变量代换，转换成线性方程。</p><h3 id="伯努利方程转换为线性方程"><a href="#伯努利方程转换为线性方程" class="headerlink" title="伯努利方程转换为线性方程"></a>伯努利方程转换为线性方程</h3><p>方程两端同时除以 $y^n$ ，得到<br>$$<br>y^{-n}\frac{dy}{dx} + P(x)y^{1-n} = Q(x)<br>$$</p><p>$$<br>\frac{d(y^{1-n})}{dx} = (1-n)y^{-n} \frac{dy}{dx}<br>$$</p><p>令 $z=y^{1-n}$ ，$\frac{dz}{dx} = (1-n)y^{-n} \frac{dy}{dx}$</p><p>则化为了线性方程<br>$$<br>\frac{dz}{dx} + (1-n)P(x)z = (1-n)Q(x)<br>$$<br>求出通解之后，把z代入，得到伯努利方程的通解</p><h1 id="二阶线性微分方程"><a href="#二阶线性微分方程" class="headerlink" title="二阶线性微分方程"></a>二阶线性微分方程</h1><p>有三种类型的多阶微分方程</p><ul><li>$y^{(n)}=f(x)$</li><li>$y’’=f(x,y’)$</li><li>$y’’=f(y,y’)$</li></ul><h2 id="y-n-f-x"><a href="#y-n-f-x" class="headerlink" title="$y^{(n)}=f(x)$"></a>$y^{(n)}=f(x)$</h2><p>这类方程解法简单暴力，有多少次阶，就求多少次原函数，最终将会求出一个和阶数量相等的常数个数的通解。例如n阶方程将会解出含有n个任意常数的通解<br>$$<br>y^{(n)}=f(x) =&gt; \frac{dy^{(n-1)}}{dx} = f(x) =&gt; y^{(n-1)} = \int f(x)dx + C_1 \\<br>y^{(n-2)} = \int [\int f(x)dx + C_1]dx + C_2<br>$$<br>以此类推解下去即可</p><h2 id="y’’-f-x-y’"><a href="#y’’-f-x-y’" class="headerlink" title="$y’’=f(x,y’)$"></a>$y’’=f(x,y’)$</h2><p>这类方程由于右端不显示含有未知数y，所以我们要用换元法</p><p>令 $y’=p$ ，则 $y’’=\frac{dp}{dx}=p’$</p><p>则原方程变换为<br>$$<br>p’ = f(x,p)<br>$$<br>这样就成了普通的一阶微分方程，先把p求出来，然后p就是y的导数，再对y积分即可</p><p>设通解为 $p=y’=h(x,C_1), y=\int h(x,C_1)dx + C_2$ </p><h2 id="y’’-f-y-y’"><a href="#y’’-f-y-y’" class="headerlink" title="$y’’=f(y,y’)$"></a>$y’’=f(y,y’)$</h2><p>这类方程右端不明显地含有自变量x，所以也要使用换元法，同时借助复合函数求导法则。</p><p>我们使用换元法，令 $y’=p$ </p><p>由于这里y为隐函数，所以可以认为y=y(x)，所以y’’也就是p’也就是对p求导，同时p是y(x)和p(y)复合而成，根据复合函数求导法则有如下</p><p> $y’’=\frac{dp}{dx}=\frac{dp}{dy}\frac{dy}{dx} = p\frac{dp}{dy} = f(y,p)$</p><p>设他的通解为<br>$$<br>y’=p=h(y,C_1)<br>$$<br>则求出原方程通解为<br>$$<br>\int \frac{dy}{h(y,C_1)} = x + C_2<br>$$</p><h1 id="高阶线性微分方程"><a href="#高阶线性微分方程" class="headerlink" title="高阶线性微分方程"></a>高阶线性微分方程</h1><h2 id="函数组的线性相关与线性无关"><a href="#函数组的线性相关与线性无关" class="headerlink" title="函数组的线性相关与线性无关"></a>函数组的线性相关与线性无关</h2><p>假设有一组函数 $y_1,y_2,y_3,…,,y_n(x)$ 为定义在区间I上的n个函数，如果存在<strong>n个不全为0的常数</strong> $k_1,k_2,..,k_n$，使得x属于I时有下列恒等式成立<br>$$<br>k_1y_1+k_2y_2+…+k_ny_n = 0<br>$$<br> 就称这一组n个函数在区间I上<strong>线性相关</strong>，<strong>否则</strong>就是<strong>线性无关</strong>。</p><p>注意这里是不全为0，也就是说可以部分为0，也可以全部不为0。</p><p>对于两个函数 y1,y2</p><p>如果 $\frac{y_1(x)}{y_2(x)}=k$ ，k为常数，则y1和y2线性相关</p><p>如果 $\frac{y_1(x)}{y_2(x)}=h(x)$ ，则y1和y2线性无关</p><h1 id="线性微分方程的一般形式"><a href="#线性微分方程的一般形式" class="headerlink" title="线性微分方程的一般形式"></a>线性微分方程的一般形式</h1><p><strong>n阶线性微分方程的一般形式</strong>如下<br>$$<br>y^{(n)}+a_1(x)y^{(n-1)}+…+a_{n-1}(x)y’+a_n(x)y = f(x)<br>$$<br>则二阶线性微分方程的一般形式就是如下<br>$$<br>y’’+P(x)y’+Q(x)y = f(x) = \frac{d^2y}{dx^2}+P(x)\frac{dy}{dx}+Q(x)y<br>$$<br>当方程右端的f(x)=0时，上诉方程叫做齐次方程，否则为非齐次</p><h1 id="齐次线性微分方程的解的结构"><a href="#齐次线性微分方程的解的结构" class="headerlink" title="齐次线性微分方程的解的结构"></a>齐次线性微分方程的解的结构</h1><p>对于二阶齐次线性方程来说</p><p>如果y1和y2分别是<strong>二阶齐次线性方程</strong>的两个解，则<br>$$<br>y=C_1y_1(x)+C_2y_2(x)<br>$$</p><p>也是这个<strong>二阶齐次线性方程</strong>的解，其中C1和C2是任意常数</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>因为y1和y2是<strong>二阶齐次线性方程</strong>的两个解，所以<br>$$<br>y_1’’+P(x)y_1’+Q(x)y_1 = 0 \\ y_2’’+P(x)y_2’+Q(x)y_2 = 0<br>$$<br>然后把 $y,y’,y’’$ 带入这个<strong>二阶齐次线性方程</strong>左端得到如下<br>$$<br>y=0=C_1y_1(x)+C_2y_2(x) = 0 = 0C_1+0C_2 = 0<br>$$<br>证毕</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>从形式上来看，上述解虽然含有C1和C2两个常数，但是他不一定是这个<strong>二阶齐次线性方程</strong>的通解</p><p>假设 $y1$ 是这个方程的一个解，则 $y2=2y1$ 也可以认为是该方程的一个解<br>$$<br>y=C_1y_1(x) + 2C_2y_1(x) = (C_1+2C_2)y_1(x) = Cy_1(x)<br>$$</p><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>如果y1和y2是<strong>二阶齐次线性方程</strong>的两个<strong>线性无关的特解</strong>，则<br>$$<br>y = C_1y_1(x)+C_2y_2(x)<br>$$<br>就是这个方程的通解</p><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>如果 y1,y2,y3,…,yn 是<strong>n阶齐次线性方程</strong>的n个<strong>线性无关</strong>的解，则此方程的通解为<br>$$<br>y = C_1y_1(x)+C_2y_2(x)+…+C_ny_n(x)<br>$$<br>其中的C1,C2,Cn为任意常数</p><h1 id="非齐次线性微分方程的解的结构"><a href="#非齐次线性微分方程的解的结构" class="headerlink" title="非齐次线性微分方程的解的结构"></a>非齐次线性微分方程的解的结构</h1><p>非齐次方程<br>$$<br>y’’+P(x)y’+Q(x)y=f(x)<br>$$<br>与非齐次方程对应的齐次方程<br>$$<br>y’’+P(x)y’+Q(x)y=0<br>$$</p><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><p>设y*是二阶非齐次线性方程(46)的一个特解，Y(x)是与(46)对应的齐次方程(47)的通解，则<br>$$<br>y=Y(x)+y\ast(x)<br>$$<br>是二阶非齐次线性微分方程(46)的通解</p><h2 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h2><p>假设 下列结论成立<br>$$<br>y=Y(x)+y\ast(x)<br>$$<br>则根据导数相加原则，有<br>$$<br>y’ = Y’(x) + y\ast’ \\<br>y’’ = Y’’(x) + y\ast’’<br>$$<br>把y,y’,y’’全部带入方程左端得到<br>$$<br>(Y’’+y<em>‘’)+P(x)(Y’+y</em>‘)+Q(x)(Y+y*) = f(x)<br>$$<br>通过加法结合律，可以转换为<br>$$<br>[y’’+P(x)Y’+Q(x)Y] + [y \ast’’+P(x)y \ast’+Q(x)y \ast] = 0+f(x) = f(x)<br>$$<br>由于下列式子中也含有两个任意常数<br>$$<br>y=Y+y\ast<br>$$<br>从而它就是二阶非齐次线性方程的通解</p><h1 id="解的叠加原理"><a href="#解的叠加原理" class="headerlink" title="解的叠加原理"></a>解的叠加原理</h1><h2 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h2><p>设非齐次线性方程的右端f(x)是两个函数之和</p><p>也就是有如下公式<br>$$<br>y’’+P(x)y’+Q(x)y=f(x)=f_1(x)+f_2(x)<br>$$<br>如果</p><ul><li><p><code>y1*(x)</code> 是 $y’’+P(x)y’+Q(x)y=f_1(x)$的特解 </p></li><li><p><code>y2*(x)</code> 是 $y’’+P(x)y’+Q(x)y=f_2(x)$的特解 </p></li></ul><p>则 $y1\ast(x)+y2\ast(x)$  就是原方程的特解</p><h2 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h2><p>对于上述定理中的式子，有</p><p>$$<br>y = y1 \ast(x)+y2 \ast(x)<br>$$</p><p>将上述式子带入方程左端，得到</p><p>$$<br>(y_1^ \ast+y_2^ \ast)’’+P(x)(y_1^ \ast+y_2^ \ast)+Q(x)(y_1^ \ast+y_2^ \ast) = f_1(x) + f_2(x)<br>$$</p><p>通过加法结合律和乘法分配律，可以转换为</p><p>$$<br>[y_1 \ast’’+P(x)y_1 \ast’+Q(x)y_1 \ast] + [y_2 \ast’’+P(x)y_2 \ast’+Q(x)y_2 \ast] = f_1(x)+f_2(x)<br>$$</p><p>所以定理成立</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667051" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667051</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667052" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667052</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667053" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667053</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667054" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1002321010&amp;from=study#/learn/content?type=detail&amp;id=1003098871&amp;cid=1003667054</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>反常积分</title>
      <link href="/2018/12/07/%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/"/>
      <url>/2018/12/07/%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="正常积分"><a href="#正常积分" class="headerlink" title="正常积分"></a>正常积分</h1><p>正常积分都在有限的上下限内积分，在无穷区间上的积分为反常积分</p><p>有界是可积的必要条件，无界函数的反常积分</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>$$<br>\lim\limits_{t \to \infty}{ \int_a^t f(x)dx } = \int_a^{+\infty} f(x)dx<br>$$</p><p>为函数f(x)在 [a,+无穷) 上的反常积分</p><p>如果上述极限存在，则反常积分收敛，并且把该<strong>极限的值</strong>称为该<strong>反常积分的值</strong></p><p>如果上述极限不存在，则反常积分发散</p><p>把上述结论改成下限为负无穷，上限为b也同样成立</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936324&amp;cid=1006265629" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936324&amp;cid=1006265629</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>牛顿莱布尼茨公式</title>
      <link href="/2018/12/06/%E7%89%9B%E9%A1%BF%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/12/06/%E7%89%9B%E9%A1%BF%E8%8E%B1%E5%B8%83%E5%B0%BC%E8%8C%A8%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="积分上限函数"><a href="#积分上限函数" class="headerlink" title="积分上限函数"></a>积分上限函数</h1><p>函数f(x)∈C[a,b]，则对任意属于x∈[a,b]，f(x)在[a,x]上可积，由此定义了一个函数<br>$$<br>y(x) = \int_a^x f(x)dx,  x∈[a,b]<br>$$<br>这个函数指的是以a为起点，x为终点，这段区间内，由x=a和x=x，以及f(x)和x轴围成的图形面积</p><p>称为 <strong>积分上限函数</strong> 或 <strong>变上限积分函数</strong></p><p>x表示积分变量，同时也是积分上限</p><h1 id="积分上限函数的导数"><a href="#积分上限函数的导数" class="headerlink" title="积分上限函数的导数"></a>积分上限函数的导数</h1><p>积分上限函数在[a,b]上可导，并且其导函数为<br>$$<br>y’(x) = \frac{d {\int_a^x f(t)dt} }{dx}, (a&lt;=x&lt;=b)<br>$$<br>证明过程请查看参考资料</p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>如果函数f ∈ C[a,b] 则积分上限函数 $y(x) = \int_a^x f(t)dt$ 就是f(x)在[a,b]上的一个原函数</p><h1 id="牛顿莱布尼茨公式"><a href="#牛顿莱布尼茨公式" class="headerlink" title="牛顿莱布尼茨公式"></a>牛顿莱布尼茨公式</h1><p>如果函数在[a,b]上有定义，函数F(x)是f(x)在[a,b]上的一个原函数，则有<br>$$<br>\int f(x)dx = F(b) - F(a)<br>$$</p><h1 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h1><p>因为F(x)和积分上限函数都是f(x)的原函数，则有<br>$$<br>F(x) = y(x) + C_0<br>$$<br>于是<br>$$<br>F(b)-F(a) = y(b) - y(a) = \int_a^b f(x)dx - \int_a^a f(x)dx = \int_a^b f(x)dx<br>$$</p><h1 id="微积分基本公式"><a href="#微积分基本公式" class="headerlink" title="微积分基本公式"></a>微积分基本公式</h1><p>牛顿-莱布尼茨公式提供了计算定积分的一个重要方法， 同时还建立了定积分与原函数之间的关系. 因此，也被称为<strong>微积分基本公式</strong> </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265608" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265608</a></p></li><li><p><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265619" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265619</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>定积分</title>
      <link href="/2018/12/05/%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2018/12/05/%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>函数f(x)在[a,b]上有界，将这一段划分为无数个dx，以每个dx中的一个函数值为高度，乘以dx，然后把每个小段都这样做并且相加，当dx趋于0的时候，这些小段相加的和，就是这个函数在区间内的定积分了。</p><h1 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h1><p>$$<br>\int_a^b f(x)dx \ [a,b]<br>$$</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul><li>当积分上下限一样的时候，积分为0</li><li>当a&gt;b时， $\int_a^b f(x)dx = - \int_b^a f(x)dx $</li><li>线性性质  $\int_a^b [f(x)±g(x)]dx = \int_a^b f(x)dx ± \int_a^b g(x)dx $ </li><li>区间可加性  $\int_a^b f(x)dx = \int_a^c f(x)dx + \int_c^b f(x)dx$</li><li>极限保号性 极限函数在某个区间内大于0，则在对应区间的积分结果也大于0 </li><li>如果两个函数，恒有f(x)大于或小于g(x)，则这两个函数的定积分的关系也同样大于或小于（保号性）</li></ul><h1 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h1><p>以这个函数曲线，两个边界，以及x轴底边围成的封闭图形的面积</p><h1 id="定积分中值定理"><a href="#定积分中值定理" class="headerlink" title="定积分中值定理"></a>定积分中值定理</h1><h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p>m和M分别是f(x)在[a,b]上的最小值和最大值，则有<br>$$<br>m(b-a) &lt;= \int f(x)dx &lt;= M(b-a), \ (a&lt;b)<br>$$</p><h2 id="定积分中值定理-1"><a href="#定积分中值定理-1" class="headerlink" title="定积分中值定理"></a>定积分中值定理</h2><p>如果函数 f (x)在[a,b]上连续，<br>则在区间[a,b]上至少存在一点 x0 ，使得下式成立<br>$$<br>\int_a^b f(x)dx = f(x_0)(b-a)<br>$$<br>以上都可以借助图形来理解</p><h1 id="存在条件"><a href="#存在条件" class="headerlink" title="存在条件"></a>存在条件</h1><ul><li>若f属于[a,b]，则f(x)在[a,b]上可积</li><li>f(x)在[a,b]上有界且只有有限个间断点，则f(x)在[a,b]上可积</li></ul><h1 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h1><h2 id="定积分表"><a href="#定积分表" class="headerlink" title="定积分表"></a>定积分表</h2><p>通过定积分表，寻找原函数，带入定积分上下限求解</p><h2 id="换元法"><a href="#换元法" class="headerlink" title="换元法"></a>换元法</h2><h3 id="定积分换元积分公式"><a href="#定积分换元积分公式" class="headerlink" title="定积分换元积分公式"></a>定积分换元积分公式</h3><p>设f(x)∈C[a,b]，如果x=g(t)满足</p><ul><li>g(m)=a, g(n)=b</li><li>g’ ∈ C[m,n] 或 g’ ∈ C[n,m] ，且g([m,n]) 或 g([n,m]) 等于 [a,b]</li></ul><p>则有如下公式<br>$$<br>\int_a^b f(x)dx = \int_m^n f[g(t)]g’(t)dt<br>$$<br>上述公式为 <strong>定积分的换元积分公式</strong> </p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设F(x)为f(x)的一个原函数，根据牛顿莱布尼茨公式<br>$$<br>\int f(x)dx = F(b) - F(a)<br>$$<br>又<br>$$<br>\int f[g(t)]g’(t)dt = \int f[g(t)]d[g(t)] = F[g(t)] + C<br>$$</p><p>则 $F[g(t)]$ 是 $f[g(t)]g’(t)$ 的一个原函数，所以有<br>$$<br>\int_m^n f[g(t)]g’(t)dt = F[g(n)] - F[g(m)] = \int_a^b f(x)dx<br>$$</p><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>令 $x = g(t)$ ，则 $ \int_a^b f(x)dx = \int_m^n f[g(t)]g’(t)dt $ ，其中 $g(m) = a, g(n) = b$ </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>当求解一些难解的定积分，可以使用换元法，换成其他更容易求解的定积分和定积分上下限</p><h2 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h2><p>分部积分公式</p><p>u(x), v(x) 在区间 [a,b] 上有连续导数，则<br>$$<br>(uv)’ = uv’ + u’v<br>$$<br>因此<br>$$<br>\int_a^b uv’ dx = \int_a^b (uv)’ dx - \int_a^b u’v dx = uv|_a^b - \int_a^b u’v dx<br>$$</p><h3 id="分部积分取值顺序"><a href="#分部积分取值顺序" class="headerlink" title="分部积分取值顺序"></a>分部积分取值顺序</h3><ul><li>反三角</li><li>对数</li><li>冥函数</li><li>三角</li><li>指数</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265606" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265606</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265607" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936320&amp;cid=1006265607</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265620" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265620</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265621" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936323&amp;cid=1006265621</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>有理函数的不定积分</title>
      <link href="/2018/12/05/%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2018/12/05/%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="有理函数"><a href="#有理函数" class="headerlink" title="有理函数"></a>有理函数</h1><p>有理函数(或有理分式)是指由两个多项式的商所表示的函数， 即具有如下形式的函数<br>$$<br>\frac{P(x)}{Q(x)} = \frac{a_0x^{n-0} + a_1x^{n-1} + a_2x^{n-2} + … + a_{n-1}x^{n-(n-1)} + a_{m-0}x^{m-m} }{ b_0x^{m-0} + b_1x^{m-1} + b_2x^{m-2} + … + b_{m-1}x^{m-(m-1)} + b_{m-0}x^{m-m} }<br>$$<br>其中m和n为非0证书，ai，bj都是实数，且a0b0≠0</p><h1 id="真分式"><a href="#真分式" class="headerlink" title="真分式"></a>真分式</h1><p>分子 P(x)的次数小于分母Q(x)的次数</p><h1 id="假分式"><a href="#假分式" class="headerlink" title="假分式"></a>假分式</h1><p>分子 P(x)的次数大于或等于分母Q(x)的次数 </p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>任一假分式总可写成一个多项式与一个真分式之和</p><h1 id="真分式的分解"><a href="#真分式的分解" class="headerlink" title="真分式的分解"></a>真分式的分解</h1><p>对于真分式 $\frac{P(x)}{Q(x)}$ 当P(x),Q(x)之间没有公因式</p><p>多项式Q(x)课分解为若干个一次多项式的乘积以及若干个判别式小于零的二次多项式的乘积</p><p>如果Q(x)=Q1(x)Q2(x)，其中Q1(x),Q2(x)之间没有公因式，则<br>$$<br>\frac{P(x)}{Q(x)} = \frac{P_1(x)}{Q_1(x)} + \frac{P_2(x)}{Q_2(x)}<br>$$</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>我们在处理有理函数的积分，可以通过上述结论将这些函数分解成多个式子，分别积分</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936319&amp;cid=1006265595" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936319&amp;cid=1006265595</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>不定积分求解</title>
      <link href="/2018/12/04/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E6%B1%82%E8%A7%A3/"/>
      <url>/2018/12/04/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="查表法"><a href="#查表法" class="headerlink" title="查表法"></a>查表法</h1><p><img src="/Users/changwei/project/blog/source/_posts/不定积分求解/table.png" alt="image-20181204134354524"></p><img src="/2018/12/04/不定积分求解/table.png" title="不定积分表"><h1 id="第一类换元法"><a href="#第一类换元法" class="headerlink" title="第一类换元法"></a>第一类换元法</h1><h2 id="换元公式"><a href="#换元公式" class="headerlink" title="换元公式"></a>换元公式</h2><p>$$<br>\int f[g(x)]g’(x)dx = F[g(x)] + C = \int f(u)du|_{u=g(x))}<br>$$</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>因为函数f(u)有原函数F(u)，也就是<br>$$<br>F’(u) = f(u), \int f(u)du = F(u) + C<br>$$<br>根据复合函数求导法则，得到<br>$$<br>\frac{dF[g(x)]}{dx} = F’[g(x)]g’(x) = f[g(x)]g’(x)<br>$$<br>所以<br>$$<br>\int f[g(x)]g’(x)dx = F[g(x)] + C<br>$$</p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>通过将原函数转换成由一个函数f(g(x))和另一个函数g’x的乘积，相当于是凑成一个复合函数的导数，然后再把gx换元成u，由于现在只剩u了，求原函数会很方便。求出原函数之后，把u所指代的gx替换原先的x即可。</p><h1 id="第二类换元法"><a href="#第二类换元法" class="headerlink" title="第二类换元法"></a>第二类换元法</h1><h2 id="换元公式-1"><a href="#换元公式-1" class="headerlink" title="换元公式"></a>换元公式</h2><p>$$<br>\int f(x)dx = \int f[g(u)]g’(u)du|_{u=g^{-1}(x))}<br>$$</p><p>$$<br>f(x)dx |_{x=g(u))} = f[g(u)]d[g(u)] = f[g(u)]g’(u)du<br>$$</p><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>先将原始函数 f(x) 分解成由两个函数复合的形式，然后 把dx中的x换成函数g(u)，求出他的不定积分之后，将g(u)带入回去即可</p><h2 id="三角代换法"><a href="#三角代换法" class="headerlink" title="三角代换法"></a>三角代换法</h2><ul><li>含 $\sqrt{a^2-x^2}$ 的可令 x=a sin t </li><li>含 $\sqrt{a^2+x^2}$ 的可令 x=a tan t </li><li>含 $\sqrt{x^2-a^2}$ 的可令 x=a sec t </li></ul><h1 id="分部积分法"><a href="#分部积分法" class="headerlink" title="分部积分法"></a>分部积分法</h1><h2 id="分部积分公式"><a href="#分部积分公式" class="headerlink" title="分部积分公式"></a>分部积分公式</h2><p>根据导数乘积法则，然后移项，得到如下公式<br>$$<br>(uv)’ = u’v + uv’, u’v = (uv)’ - uv’<br>$$</p><p>$$<br>\int u’v dx = \int (uv)’ dx - \int uv’ dx = uv - \int uv’ dx<br>$$<br>关键是要选择适当的u和v函数，使得u’v比uv’更容易求得<br>$$<br>\int udv = uv - \int vdu<br>$$</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>一般可以按照如下顺序选择u：</p><ul><li>反三角函数</li><li>对数函数</li><li>冥函数</li><li>三角函数</li><li>指数函数</li></ul><h2 id="理解-2"><a href="#理解-2" class="headerlink" title="理解"></a>理解</h2><p>通常用来求解乘积组成的积分。将一个函数视为一个原函数和一个导函数的乘积，然后通过根据导数乘积法则，分别对其求不定积分。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265587" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265587</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265588" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265588</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265589" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936316&amp;cid=1006265589</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>不定积分</title>
      <link href="/2018/12/04/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
      <url>/2018/12/04/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="求导运算"><a href="#求导运算" class="headerlink" title="求导运算"></a>求导运算</h1><p>已知F(x)，求F’(x)，导函数f(x)=F’(x)</p><h1 id="积分运算"><a href="#积分运算" class="headerlink" title="积分运算"></a>积分运算</h1><p>已知f(x)，求F(x)，满足F’(x)=f(x)</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果F(x)在区间上可导，对于任一属于该区间的x，都有<br>$$<br>F’(x) = f(x) 或 dF(x) = f(x)dx<br>$$</p><h1 id="原函数个数"><a href="#原函数个数" class="headerlink" title="原函数个数"></a>原函数个数</h1><p>如果F(x)是f(x)的一个原函数，则F(x)+C也是f(x)的原函数，其中C为任意常数</p><p><strong>原函数存在时不唯一</strong></p><p><strong>两个原函数之间至多差一个常数</strong></p><p>使用拉格朗日中值定理的推论</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>因为导数反映的仅仅是函数的变化率，而不是函数的绝对位置（高度）。所以同一个导数会有很多个原函数，所以叫做不定积分。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>$$<br>\int f(x)dx = F(x)+C<br>$$</p><p><strong>不定积分是原函数的一般表达式</strong></p><p>也可以把常数项移项写成如下形式<br>$$<br>\int f(x)dx + C = F(x)<br>$$<br>积分符号右侧写的是导函数</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="逆运算"><a href="#逆运算" class="headerlink" title="逆运算"></a>逆运算</h2><p>$$<br>\frac{d[\int f(x)dx]}{dx} = f(x), \int f’(x)dx = f(x) + C<br>$$</p><p><strong>可以看出积分和微分互为逆运算</strong></p><h2 id="运算性质"><a href="#运算性质" class="headerlink" title="运算性质"></a>运算性质</h2><p>$$<br>\int [f(x)±g(x)]dx = \int f(x)dx ± \int g(x)dx<br>$$</p><p>$$<br>\int kf(x)dx = k\int f(x)dx (k&lt;&gt;0,k!=0)<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936315&amp;cid=1006265578" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936315&amp;cid=1006265578</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936315&amp;cid=1006265579" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-217012?tid=1003485022#/learn/content?type=detail&amp;id=1004936315&amp;cid=1006265579</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>曲率</title>
      <link href="/2018/12/04/%E6%9B%B2%E7%8E%87/"/>
      <url>/2018/12/04/%E6%9B%B2%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>设曲线C 是光滑的，在曲线C 上选定一点M0作为度量弧 s 的基点.设曲线上点 M 对应于弧 s ，在点M处切线的倾角为 $\alpha $ ， 曲线上另一点M’对应于弧s+ds，在点M处切线的倾角为$\alpha + d\alpha  $ </p><p>则弧段MM’的长度为$|ds|$，当动点从M移动到M’时切线转过的角度为$|d\alpha | $ </p><p>把 $\frac{|d\alpha|}{|ds|}$ ，即单位弧段上切线转过的角度的大小称为弧段 MM’的<strong>平均曲率</strong></p><p>如果当ds趋于0的时候，平均曲率的极限存在，则称此极限为曲线C在点M处的<strong>曲率</strong>，记为K，也就是<br>$$<br>K = \lim\limits_{ds \to 0 }{ | \frac{d\alpha}{ds} | }<br>$$</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果此极限（曲率）为0，则表示该线不弯曲</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549530&amp;cid=1005705868" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549530&amp;cid=1005705868</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>泰勒公式</title>
      <link href="/2018/12/03/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/12/03/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="使用多项式近似表达函数"><a href="#使用多项式近似表达函数" class="headerlink" title="使用多项式近似表达函数"></a>使用多项式近似表达函数</h1><p>我们可以近似将函数f(x)在某个点的导数值乘以<code>自变量x</code>的微分，来求得<code>函数f(x)</code>的微分。</p><p><code>因为当`</code>dx<code>足够小的时候，可以近似认为</code>dx<code>区域内的增长率为</code>x0<code>处的增长率（事实上增长率应该是是f(x)的导数，是一个随着</code>x`变化的动态值）</p><p>然后我们可以将这个近似<code>f(x)</code>的值定义为一个新的<code>函数P1(x)</code>，对于<code>x0</code>来说，<code>P1(x)</code>的导数和他本身相等，因为<code>P1(x)</code>近似取值的时候就是去<code>x0</code>处的导数为近似增长率。<br>$$<br>\delta y ≈ dy = f’(x_0)\delta x \<br>f(x) - f(x_0) ≈ f’(x_0)(x-x_0) \<br>f(x) ≈ f(x_0)+f’(x_0)(x-x_0) = P_1(x) \<br>P_1(x_0) = f(x_0), P’_1(x_0) = f’(x_0)<br>$$<br>误差：<br>$$<br>f(x) - P_1(x) = o(x-x_0)<br>$$<br>他们的误差是<code>x-x0</code>的一个高阶数</p><h1 id="寻找这个多项式"><a href="#寻找这个多项式" class="headerlink" title="寻找这个多项式"></a>寻找这个多项式</h1><p>$$<br>P_n(x) = a_0(x-x_0)^0 + a_1(x-x_0)^1 + a_2(x-x_0)^2 + … + a_n(x-x_0)^n<br>$$</p><p>要求<br>$$<br>f(x) - P_n(x) = o((x-x_0)^n)<br>$$<br>假设<br>$$<br>P_n(x_0) = f(x_0), P_n’(x_0) = f’(x_0), P_n’’(x_0) = f’’(x_0), P_n^{(n)}(x_0) = f^{(n)}(x_0),<br>$$<br>根据 $P_n(x_0) = a_0$ 得到 $a_0 = f(x_0)$ </p><p>然后对<code>Pn</code>求导，得到如下式子<br>$$<br>P_n’(x) = 1a_1(x-x_0)^0 + 2a_2(x-x_0)^1 + 3a_3(x-x_0)^2 + … + na_n(x-x_0)^{n-1}<br>$$</p><p>因此</p><p>$$<br>P_n’(x_0) = 1 \cdot a_1(x-x_0)^0 = a_1, a_1 = f’(x_0)<br>$$</p><p>再次求导得到<code>Pn</code>的二阶导数</p><p>$$<br>P_n’’(x) = 1\cdot2a_1(x-x_0)^0 + 2\cdot3a_1(x-x_0)^1 + … + (n-1)na_n(x-x_0)^{n-2}<br>$$</p><p>因此</p><p>$$<br>P_n’’(x) = 1*2a_1(x-x_0)^0 = 2!a_1<br>$$</p><p>也就是</p><p>$$<br>a_2 = \frac{1}{2!}f’’(x_0), … , a_n = \frac{1}{n!}f^{n}(x_0)<br>$$</p><p>最终得出该多项式为</p><p>$$<br>P_n(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n<br>$$</p><h1 id="泰勒中值定理1"><a href="#泰勒中值定理1" class="headerlink" title="泰勒中值定理1"></a>泰勒中值定理1</h1><p>如果<code>函数f(x)</code>在x0处有n阶导数，则存在<code>x0</code>的一个领域，对于该领域内任一<code>x</code>，有<br>$$<br>f(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)<br>$$<br>其中 $ R_n(x) = o((x-x_0)^n) $</p><p>则称<br>$$<br>P_n(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n<br>$$<br>为<code>f(x)</code>在<code>x0</code>处按<code>x-x0</code>的冥展开的<strong>n次泰勒多项式</strong></p><p>而<br>$$<br>f(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)<br>$$<br>称为<code>f(x)</code>在<code>x0</code>处或按<code>x-x0</code>的幂展开的带有佩亚诺 (Peano)余项的 n 阶泰勒公式</p><p>上面余项的表达式称为佩亚诺余项</p><h1 id="泰勒中值定理2"><a href="#泰勒中值定理2" class="headerlink" title="泰勒中值定理2"></a>泰勒中值定理2</h1><p>如果函数f(x)在x0的某领域内具有直到n+1阶的导数，那么对任一属于x0领域的x，有<br>$$<br>f(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)<br>$$<br>其中（拉格朗日余项）<br>$$<br>R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{(n+1)}, \xi ∈ (x_0,x)<br>$$<br>称<br>$$<br>f(x) = f(x_0) + f’(x_0)(x-x_0) + \frac{1}{2!}f’’(x_0) + … + \frac{f^{(n)}(x_0)}{n!}(x-x_0)^n + R_n(x)<br>$$<br>为<code>f(x)</code>在<code>x0</code>处或按照<code>x-x0</code>的冥展开的<strong>带有拉格朗日余项</strong>的 <strong>n 阶泰勒公式</strong></p><p>当<code>n=0</code>时，泰勒公式为<br>$$<br>f(x) = f)x_0 + f’(\xi)(x-x_0), \xi ∈ (x_0,x)<br>$$</p><h1 id="带有佩亚诺余项的麦克劳林-Maclaurin-公式"><a href="#带有佩亚诺余项的麦克劳林-Maclaurin-公式" class="headerlink" title="带有佩亚诺余项的麦克劳林(Maclaurin)公式"></a>带有佩亚诺余项的麦克劳林(Maclaurin)公式</h1><p>$$<br>f(x) = f(0)x^0 + f’(0)x^1 + \frac{f’’(x_0)}{2!}x^2 + … + \frac{f^{(n)}(0)}{n!}x^n + o(x^n)<br>$$</p><h1 id="带有拉格朗日余项的麦克劳林公式"><a href="#带有拉格朗日余项的麦克劳林公式" class="headerlink" title="带有拉格朗日余项的麦克劳林公式"></a>带有拉格朗日余项的麦克劳林公式</h1><p>$$<br>f(x) = f(0)x^0 + f’(0)x^1 + \frac{f’’(x_0)}{2!}x^2 + … + \frac{f^{(n)}(0)}{n!}x^n +  \frac{f^{(n+1)}(\theta x)}{(n+1)!}x^{n+1}, ( 0 &lt; \theta &lt; 1 )<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549526&amp;cid=1005705854" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549526&amp;cid=1005705854</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用MATLAB解方程</title>
      <link href="/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E8%A7%A3%E6%96%B9%E7%A8%8B/"/>
      <url>/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E8%A7%A3%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一个博客（ <a href="https://blog.changwei.me/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E6%B1%82%E6%9E%81%E9%99%90%E5%80%BC/">https://blog.changwei.me/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E6%B1%82%E6%9E%81%E9%99%90%E5%80%BC/</a> ）我们提到了如何使用<code>MATLAB</code>求极限值。</p><p>这篇文章我们将讲解如何使用<code>MATLAB</code>解方程。</p><p>我们平时做物理题，使用回路电流法求电路的电压电流时，有多少个回路就要列写多少个方程。</p><p>碰到回路多的电路，普通工程计算器甚至都无法完成，这个时候就需要强大的<code>MATLAB</code>的<code>solve</code>函数来帮我们解方程组了。</p><h1 id="solve"><a href="#solve" class="headerlink" title="solve"></a>solve</h1><p>输入<code>help solve</code>获取函数的函数原型和参数意义</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help solve</span><br><span class="line">solve - Equations and systems solver</span><br><span class="line"></span><br><span class="line">    This MATLAB <span class="function"><span class="keyword">function</span> <span class="title">solves</span> <span class="title">the</span> <span class="title">equation</span> <span class="title">eqn</span> <span class="title">for</span> <span class="title">the</span> <span class="title">variable</span> <span class="title">var</span>.</span></span><br><span class="line"></span><br><span class="line">    S = solve(eqn,var)</span><br><span class="line">    S = solve(eqn,var,Name,Value)</span><br><span class="line">    Y = solve(eqns,vars)</span><br><span class="line">    Y = solve(eqns,vars,Name,Value)</span><br><span class="line">    [y1,...,yN] = solve(eqns,vars)</span><br><span class="line">    [y1,...,yN] = solve(eqns,vars,Name,Value)</span><br><span class="line">    [y1,...,yN,parameters,conditions] = solve(eqns,vars,<span class="string">'ReturnConditions'</span>,<span class="built_in">true</span>)</span><br><span class="line"></span><br><span class="line">    另请参阅 dsolve, isolate, linsolve, root, subs, symvar, vpasolve</span><br><span class="line"></span><br><span class="line">    solve 的参考页</span><br></pre></td></tr></table></figure><p>这里要着重注意，<code>solve</code>如果求解的是多元方程组，返回的则是一个struct结构体类型（类似于python中的list），也就是包含多个值得数据类型，所以有几个未知数，我们就要使用syms声明多少个未知数，并且需要让<code>solve</code>赋值给由这些未知数组成的struct（类似于python中的list）</p><p>然后eqns就是方程组了，也要使用方括号包裹起来，类似于python中的list，vars是未知数，也要写成struct类型并且使用方括号包裹起来。实际测试发现不用包裹也可以，当然推荐还是写成struct类型，比较规范。</p><p><strong>还有一个要注意的地方，就是在<code>MATLAB</code>中，单等于号<code>=</code>是赋值作用，而双等于号<code>==</code>才是相等，和C系列编程语言一样。</strong></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>求解一个七元一次方程</p><p>首先使用clear命令清除环境中已经存在的变量，防止被干扰，然后输入如下命令即可</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; clear</span><br><span class="line">&gt;&gt; syms i1 i2 i3 i4 i5 i6 vx</span><br><span class="line">&gt;&gt;  [i1,i2,i3,i4,i5,i6,vx] = solve([<span class="number">12</span>+(<span class="number">2</span>*i1-i4)*<span class="number">1000</span>==<span class="number">0</span>,<span class="number">12</span>+(<span class="number">2</span>*i2-i3-i5)*<span class="number">1000</span>==<span class="number">0</span>,<span class="number">2</span>*vx+(<span class="number">2</span>*i4-i1+i5)*<span class="number">1000</span>==<span class="number">0</span>,i3==<span class="number">6</span>/<span class="number">1000</span>,(<span class="number">2</span>*i5-i2+i4)*<span class="number">1000</span>==vx+(i6+i3)*<span class="number">1000</span>,i5+i6==<span class="number">2</span>*(i4+i5),i6*<span class="number">1000</span>==vx],[i1,i2,i3,i4,i5,i6,vx])</span><br><span class="line"> </span><br><span class="line">i1 =</span><br><span class="line"> </span><br><span class="line"><span class="number">-81</span>/<span class="number">12500</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i2 =</span><br><span class="line"> </span><br><span class="line"><span class="number">-39</span>/<span class="number">12500</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i3 =</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span>/<span class="number">500</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i4 =</span><br><span class="line"> </span><br><span class="line"><span class="number">-3</span>/<span class="number">3125</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i5 =</span><br><span class="line"> </span><br><span class="line"><span class="number">-3</span>/<span class="number">12500</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">i6 =</span><br><span class="line"> </span><br><span class="line"><span class="number">-27</span>/<span class="number">12500</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">vx =</span><br><span class="line"> </span><br><span class="line"><span class="number">-54</span>/<span class="number">25</span></span><br><span class="line"> </span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><p>可以看到七个元分别被正确求出</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用MATLAB求极限值</title>
      <link href="/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E6%B1%82%E6%9E%81%E9%99%90%E5%80%BC/"/>
      <url>/2018/12/03/%E4%BD%BF%E7%94%A8MATLAB%E6%B1%82%E6%9E%81%E9%99%90%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在做高等数学题目时，需要验证自己答案的正确性，我们可以使用<code>MATLAB</code>来自动化求解极限值</p><h1 id="syms"><a href="#syms" class="headerlink" title="syms"></a>syms</h1><p>首先要使用 <code>syms</code> 定义一个符号变量，你也可以理解为数学中的一些未知数，例如x。</p><h1 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h1><p>这是求极限的函数，我们可以输入 <code>help limit</code> 来查看它的函数原型和参数意义</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; help limit</span><br><span class="line">--- sym/limit 的帮助 ---</span><br><span class="line"></span><br><span class="line"> limit    Limit of an expression.</span><br><span class="line">    limit(F,x,a) takes the limit of the symbolic expression F as x -&gt; a.</span><br><span class="line">    limit(F,a) uses symvar(F) as the independent variable.</span><br><span class="line">    limit(F) uses a = <span class="number">0</span> as the limit point.</span><br><span class="line">    limit(F,x,a,<span class="string">'right'</span>) or limit(F,x,a,<span class="string">'left'</span>) specify the direction</span><br><span class="line">    of a one-sided limit.</span><br><span class="line"> </span><br><span class="line">    Examples:</span><br><span class="line">      syms x a t h;</span><br><span class="line"> </span><br><span class="line">      limit(<span class="built_in">sin</span>(x)/x)                 returns   <span class="number">1</span></span><br><span class="line">      limit((x<span class="number">-2</span>)/(x^<span class="number">2</span><span class="number">-4</span>),<span class="number">2</span>)          returns   <span class="number">1</span>/<span class="number">4</span></span><br><span class="line">      limit((<span class="number">1</span>+<span class="number">2</span>*t/x)^(<span class="number">3</span>*x),x,<span class="built_in">inf</span>)    returns   <span class="built_in">exp</span>(<span class="number">6</span>*t)</span><br><span class="line">      limit(<span class="number">1</span>/x,x,<span class="number">0</span>,<span class="string">'right'</span>)          returns   <span class="built_in">inf</span></span><br><span class="line">      limit(<span class="number">1</span>/x,x,<span class="number">0</span>,<span class="string">'left'</span>)           returns   -<span class="built_in">inf</span></span><br><span class="line">      limit((<span class="built_in">sin</span>(x+h)-<span class="built_in">sin</span>(x))/h,h,<span class="number">0</span>)  returns   <span class="built_in">cos</span>(x)</span><br><span class="line">      v = [(<span class="number">1</span> + a/x)^x, <span class="built_in">exp</span>(-x)];</span><br><span class="line">      limit(v,x,<span class="built_in">inf</span>,<span class="string">'left'</span>)           returns   [<span class="built_in">exp</span>(a),  <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sym/limit 的参考页</span><br></pre></td></tr></table></figure><p>可以看到</p><p><code>limit(F,x,a) takes the limit of the symbolic expression F as x -&gt; a.</code></p><p><code>F</code>表示要求极限的函数，<code>x</code>表示自变量，<code>a</code>表示自变量<code>x</code>趋向于的值，可以为任意数，或者无穷，但是无穷要使用<code>inf</code>来代替</p><p><code>limit(F,x,a,&#39;right&#39;) or limit(F,x,a,&#39;left&#39;) specify the direction of a one-sided limit.</code></p><p>而第四个参数如果输入<code>&#39;left&#39;</code>或者<code>&#39;right&#39;</code>，则表示求<strong>左极限</strong>或者<strong>右极限</strong>。<strong>这里要注意参数类型是string，要用单引号包裹起来。</strong></p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>例如我求 $\lim\limits_{n \to \infty }{\frac{x-sin\ x}{x}} $ 的极限，可以这样操作</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; syms x</span><br><span class="line">&gt;&gt; limit((x-<span class="built_in">sin</span>(x))/x,x,<span class="built_in">inf</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>首先声明<code>符号变量x</code>，然后执行<code>limit</code>即可得到极限值为<code>1</code></p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>洛必达法则</title>
      <link href="/2018/12/02/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/"/>
      <url>/2018/12/02/%E6%B4%9B%E5%BF%85%E8%BE%BE%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果当x趋向于a或者无穷时，f(x),g(x)都趋于0或无穷大时，则极限 $\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f(x)}{g(x)} } $ 可能存在，也可能不存在</p><p>通常把这种极限叫做<strong>未定式</strong>，记作 $\frac{0}{0} 或 \frac{\infty}{\infty}$ </p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><ul><li><p>当x趋于a时，f(x),g(x)都趋于0或无穷大</p></li><li><p>在a的某去心邻域内，f’(x),g’(x)都存在且g’(x)≠0</p></li><li><p>$\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f^{‘}(x)}{g^{‘}(x)} } $ 存在（或为无穷大）</p><p>则有<br>$$<br>\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f(x)}{g(x)} } =<br>\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f^{‘}(x)}{g^{‘}(x)} }<br>$$<br>若 $\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f^{‘}(x)}{g^{‘}(x)} }$ 仍然为未定式，且满足上述定理条件，则<br>$$<br>\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f(x)}{g(x)} } =<br>\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f^{‘}(x)}{g^{‘}(x)} } =<br>\lim\limits_{x \to \infty \  or \ x \to a }{ \frac{f^{‘’}(x)}{g^{‘’}(x)} }<br>$$</p></li></ul><p>以此类推</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549526&amp;cid=1005705853" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549526&amp;cid=1005705853</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微分中值定理</title>
      <link href="/2018/12/01/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2018/12/01/%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="罗尔（Rolle）定理"><a href="#罗尔（Rolle）定理" class="headerlink" title="罗尔（Rolle）定理"></a>罗尔（Rolle）定理</h1><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>设<code>曲线弧AB</code>： $ y=f(x) (x∈[a,b]) $ </p><p>除端点以外，处处有不垂直于<code>x轴</code>的切线，且 $f(a)=f(b)$ 则曲线有水平切线</p><p>如果记<code>C点</code>的横坐标为<code>x0</code>，则<code>f&#39;(x0)=0</code></p><p><img src="/Users/changwei/project/blog/source/_posts/微分中值定理/rolle.png" alt="image-20181201162453473"></p><img src="/2018/12/01/微分中值定理/rolle.png" title="罗尔定理"><h2 id="费马引理"><a href="#费马引理" class="headerlink" title="费马引理"></a>费马引理</h2><p><code>函数f(x)</code>在<code>点x0</code>的<code>某邻域U(x0)</code>内有定义，且在<code>x0</code>处可导，如果对于任意属于<code>U(x0)</code>的<code>x</code>，有<br>$$<br>f(x)&lt;=f(x_0) (或 f(X)&gt;=f(x_0))<br>$$<br>那么 <code>f&#39;(x0)=0</code> </p><p>理解：因为如果一个点是一段曲线中的极值，则它的切线肯定平行于x轴</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>导数等于<code>0</code>的点成为函数的驻点（稳定点，临界点）</li><li>函数在<code>x0</code>处可导，且<code>f(x0)</code>是<code>f(x)</code>在<code>U(x0)</code>上的最大最小值，则<code>f&#39;(x0)=0</code></li><li>费马引理的逆未必成立，例如 y=x^3 这个函数，在x=0的时候并不是最大值或者最小值</li></ul><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>设f(x)在x0可导，任取一个属于U(x0)的x，有f(x)&lt;=f(x0) （&gt;=）那么f’(x0)=0</p><h2 id="罗尔定理"><a href="#罗尔定理" class="headerlink" title="罗尔定理"></a>罗尔定理</h2><p>如果函数满足如下三个条件：</p><ul><li><p>在闭区间[a,b]上连续</p></li><li><p>在开区间(a,b)内可导</p></li><li><p>在区间端点处的函数值相等，即f(a)=f(b)</p><p>那么在(a,b)内至少有一点x0（a&lt;x0&lt;b）使得f’(x0)=0</p></li></ul><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>如果不满足定理的条件，则定理的结论可能成立，也可能不成立</p><h1 id="拉格朗日（Lagrange）中值定理"><a href="#拉格朗日（Lagrange）中值定理" class="headerlink" title="拉格朗日（Lagrange）中值定理"></a>拉格朗日（Lagrange）中值定理</h1><p>若函数f(x)满足</p><ul><li>在闭区间[a,b]连续</li><li>在开区间(a,b)可导</li></ul><p>则在(a,b)内至少存在一点x0(a&lt;x0&lt;b)，使得 $f(b)-f(a)=f’(x_0)(b-a)$ </p><h2 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h2><p>如果f(a)=f(b) 则此定理的结论就是罗尔定理的结论</p><p>所以：<strong>罗尔定理是拉格朗日中值定理的特殊情形</strong></p><h2 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h2><p>连续曲线弧AB，除了端点外，处处都有不垂直于x轴的切线，则在此曲线弧上至少有一点C，C处的切线与弦AB平行。</p><h1 id="柯西（Cauchy）中值定理"><a href="#柯西（Cauchy）中值定理" class="headerlink" title="柯西（Cauchy）中值定理"></a>柯西（Cauchy）中值定理</h1><ul><li>在闭区间[a,b]上连续</li><li>在开区间(a,b)内可导</li><li>对任一x属于(a,b)，F’(x)≠0</li></ul><p>则在(a,b)内至少有一点x0，使得<br>$$<br>\frac{f(b)-f(a)}{F(b)-F(a)} = \frac{f’(x_0)}{F’(x_0)}<br>$$</p><h2 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h2><p>如果F(x)=x，则此定理的结论正是拉格朗日中值定理的结论</p><p><strong>拉格朗日中值定理是柯西中值定理的特殊情形</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549525&amp;cid=1005705845" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549525&amp;cid=1005705845</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微分</title>
      <link href="/2018/12/01/%E5%BE%AE%E5%88%86/"/>
      <url>/2018/12/01/%E5%BE%AE%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>函数 <code>y=f(x)</code> 在某区间内有定义，x0以及x0+△x在这个区间内，如果函数增量<br>$$<br>△y=f(x_0+△x)-f(x_0)<br>$$<br>可以表示为（o表示高阶，由于△x趋向于0的时候，高阶无穷小相对来说很小，可以忽略不计）<br>$$<br>△y=A△x+o(△x)<br>$$<br>其中<code>A</code>是不依赖<code>△x</code>的<strong>常数</strong>，那么称函数在<code>点x0</code>处△，而<code>A△x</code>叫做函数在<code>点x0</code>相应于<code>自变量增量△x</code>的<strong>微分</strong>，记作<code>dy</code>，也就是<code>dy=A△x</code></p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p><code>函数f(x)</code>在<code>点x0</code><strong>可微</strong> &lt;=&gt;函数在<code>点x0</code><strong>可导</strong></p><p>且<code>函数f(x)</code>在<code>点x0</code><strong>可微</strong>，<strong>微分</strong>一定是<br>$$<br>dy=f’(x_0)△x<br>$$</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ul><li><code>函数f(x)</code>在<code>任意点x</code>的<strong>微分</strong>称为<strong>函数的微分</strong>，记作<code>dy</code>或者<code>df(x)</code>，即 $dy=f’(x)△x$</li><li>自变量的<code>增量 △x</code> 称为<strong>自变量的微分</strong>，记作<code>dx</code>，即 $dx=△x$ </li></ul><p>$$<br>dy=f’(x)dx,\frac{dy}{dx}=f’(x)<br>$$</p><p>导数又称<strong>“微商”</strong></p><h1 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h1><p>对于一段连续的曲线中的部分一小段，我们可以使用这一小段中某点的切线来近似代替这一小段曲线</p><h1 id="微分运算法则"><a href="#微分运算法则" class="headerlink" title="微分运算法则"></a>微分运算法则</h1><p>将导数的和差积商的公式中的导数符号<code>&#39;</code>改写成<code>d</code>，表示 delta △ 的意思</p><h1 id="复合函数微分法则"><a href="#复合函数微分法则" class="headerlink" title="复合函数微分法则"></a>复合函数微分法则</h1><p>y=f(u),u=g(x)都可导，则 $y=f[g(x)]$ 的微分为<br>$$<br>dy=f’(u)g’(x)dx<br>$$<br>另外<br>$$<br>g’(x)dx=du<br>$$<br>所以<br>$$<br>dy=f’(u)du<br>$$</p><h1 id="微分形式的不变性"><a href="#微分形式的不变性" class="headerlink" title="微分形式的不变性"></a>微分形式的不变性</h1><p>无论 <code>u</code> 是自变量还是中间变量，上述微分形式保持不变</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549525&amp;cid=1005705844" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549525&amp;cid=1005705844</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>由参数方程所确定的函数的导数</title>
      <link href="/2018/12/01/%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E6%89%80%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/"/>
      <url>/2018/12/01/%E7%94%B1%E5%8F%82%E6%95%B0%E6%96%B9%E7%A8%8B%E6%89%80%E7%A1%AE%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="参数方程"><a href="#参数方程" class="headerlink" title="参数方程"></a>参数方程</h1><p>$$<br>\left{<br>\begin{array}{rcl}<br>x=acos\ t &amp; &amp; {0&lt;=t&lt;=2π}\<br>y=asin\ t &amp; &amp; {0&lt;=t&lt;=2π}<br>\end{array} \right.<br>$$</p><p>$$<br>\left\{<br>\begin{array}{rcl}<br>x=acos\ t &amp; &amp; {0&lt;=t&lt;=2π}\\<br>y=asin\ t &amp; &amp; {0&lt;=t&lt;=2π}<br>\end{array} \right.<br>$$</p><p>t=0，x=a，y=0</p><p>消去t，可得<br>$$<br>y=\sqrt{a^2-x^2}(0&lt;=t&lt;=π)或者y=-\sqrt{a^2-x^2}(π&lt;t&lt;=2π)<br>$$<br>若参数方程确定了y与x的函数关系，则称此函数关系所表达的函数为<strong>由参数方程所确定的函数</strong></p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>有时由参数方程所确定的函数，未必很容易写出其函数的显示表示，比如：摆线方程<br>$$<br>\left{<br>\begin{array}{rcl}<br>x=a(t-sin\ t) &amp; &amp; {0&lt;=t&lt;=2π}\<br>y=a(1-cos\ t) &amp; &amp; {0&lt;=t&lt;=2π}<br>\end{array} \right.<br>$$</p><p>$$<br>\left\{<br>\begin{array}{rcl}<br>x=a(t-sin\ t) &amp; &amp; {0&lt;=t&lt;=2π}\\<br>y=a(1-cos\ t) &amp; &amp; {0&lt;=t&lt;=2π}<br>\end{array} \right.<br>$$</p><h1 id="参数方程求导方法"><a href="#参数方程求导方法" class="headerlink" title="参数方程求导方法"></a>参数方程求导方法</h1><p>设参数方程<br>$$<br>\left{<br>\begin{array}{rcl}<br>x=f(t) \<br>y=g(t)<br>\end{array} \right.<br>$$<br>$$<br>\left\{<br>\begin{array}{rcl}<br>x=f(t) \\<br>y=g(t)<br>\end{array} \right.<br>$$</p><p>假设x=f(t)有单调连续的反函数 $t=f^{-1}(x)$ 且此反函数能与函数 y=g(t) 构成复合函数，那么由此参数方程所确定的函数可以看做是由 $y=g(x), t=f^{-1}(x),f’(t)≠0$ </p><p>$$<br>\left{<br>\begin{array}{rcl}<br>x=f(t) \<br>y=g(t) \<br>t=f^{-1}(x)<br>\end{array} \right.<br>$$</p><p>$$<br>\left\{<br>\begin{array}{rcl}<br>x=f(t) \\<br>y=g(t) \\<br>t=f^{-1}(x)<br>\end{array} \right.<br>$$</p><p>$$<br>\frac{dy}{dx} =<br>\frac{dy}{dt}\frac{dt}{dx} =<br>\frac{dy}{dt}\frac{1}{ \frac{dt}{dx} } =<br>\frac{g^{‘}(t)}{f^{‘}(t)}<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705836" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705836</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>隐函数的导数</title>
      <link href="/2018/12/01/%E9%9A%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/"/>
      <url>/2018/12/01/%E9%9A%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="显函数"><a href="#显函数" class="headerlink" title="显函数"></a>显函数</h1><p>例如 $y=sin\ x+1$ 为显函数，因为它左端是因变量符号，右边是含有自变量的式子。</p><p>当自变量在定义域内任取一值时，又该式能确定对应的函数值，用这种方式表达的函数叫做显函数。</p><h1 id="隐函数"><a href="#隐函数" class="headerlink" title="隐函数"></a>隐函数</h1><p>例如 $sin\ x-y^3+2=0$ ，它表示一函数，因为当<code>变量x</code>在<code>R实数集合</code>内取值时，<code>变量y</code>有确定的值与它对应，例如<code>x=0</code>时， <code>y=2</code>的三次根号。当x=<code>二分之pi</code>时，y=<code>3的三次根号</code>。</p><p>这样的函数称为隐函数  </p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果变量x和y满足 $F(x,y)=0$ ，在一定条件下，当<code>x</code>取某区间的任一值时，相应地总有满足此方程的唯一的<code>y</code>值存在，那么就说方程 $F(x,y)=0$ 在该区间内确定了一个<strong>隐函数</strong>。</p><h1 id="隐函数的显化"><a href="#隐函数的显化" class="headerlink" title="隐函数的显化"></a>隐函数的显化</h1><p>把一个隐函数化成显函数</p><h1 id="隐函数的导数"><a href="#隐函数的导数" class="headerlink" title="隐函数的导数"></a>隐函数的导数</h1><p>$F(x,y)=0$ 确定 $y=y(x)$ ，得到 $F[x,y(x)]=0$ ，在 $F[x,y(x)]=0$ 两边对<code>x</code>求导，即可得到隐函数的导数</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705836" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705836</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>导数</title>
      <link href="/2018/11/30/%E5%AF%BC%E6%95%B0/"/>
      <url>/2018/11/30/%E5%AF%BC%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="切线的定义"><a href="#切线的定义" class="headerlink" title="切线的定义"></a>切线的定义</h1><p><code>A</code>是<code>曲线C</code>上的一点，<code>B</code>是另一点，做<code>割线AB</code>，当<code>B</code>沿着<code>曲线C</code>移动趋向于<code>点A</code>时，如果<code>割线AB</code>绕<code>点A</code>旋转而趋于一极限位置，也就是<code>直线AT</code>，则称<code>直线AT</code>为曲线<code>f(x)</code>在<code>点A</code>处的<strong>切线</strong></p><h1 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h1><h2 id="函数在一点处的导数"><a href="#函数在一点处的导数" class="headerlink" title="函数在一点处的导数"></a>函数在一点处的导数</h2><p>当<code>函数f(x)</code>在<code>点x0</code>的某个领域内有定义，当<code>自变量x</code>在<code>x0</code>处取得<code>增量dx</code>（x0+dx仍在该领域内）时，<code>因变量y</code>相应地取得增量<code>dy=f(x0+dx)-f(x0)</code></p><p>如果 $\lim\limits_{x \to 0 }{\frac{\delta y}{\delta x}}$ 存在，则称<code>函数f(x)</code>在<code>点x0</code>处*<em>可导</em></p><p>并称该极限为f(x)在点x0处的导数，记为f’(x0)<br>$$<br>\lim\limits_{x \to 0 }{\frac{\delta y}{\delta x}} = \lim\limits_{x \to 0 }\frac{f(x_0 + \delta x) - f(x_0)}{\delta x}<br>$$</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>导数值表示函数在某点的变化率</p><h1 id="不可导"><a href="#不可导" class="headerlink" title="不可导"></a>不可导</h1><p>$$<br>\lim\limits_{x \to 0 }{\frac{\delta y}{\delta x}} = \lim\limits_{x \to 0 }\frac{f(x_0 + \delta x) - f(x_0)}{\delta x}<br>$$</p><p>这个极限不存在，则函数在<code>x0</code>处不可导</p><h1 id="导函数的定义"><a href="#导函数的定义" class="headerlink" title="导函数的定义"></a>导函数的定义</h1><p>如果函数在<code>开区间I</code>内每一个点处都可导，则称函数在<code>开区间I</code>内可导，这时对于任意一个属于<code>I</code>的数，都存在f(x)的一个确定的导数值，这样就构成了一个新的函数，这个函数称为原来函数的导函数（导数）</p><p>记作 $f’(x),y’,\frac{dy}{dx},\frac{df(x)}{dx}$</p><h1 id="单侧导数"><a href="#单侧导数" class="headerlink" title="单侧导数"></a>单侧导数</h1><p>$f_-‘(x_0),f_+’(x_0),$ 左右极限，指的是从负数趋向于0或者从正数趋向于0</p><p>左右极限存在且相等才表示函数在x0处可导</p><h1 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h1><p>指的是函数在某个点的切线</p><h1 id="连续性与可导性"><a href="#连续性与可导性" class="headerlink" title="连续性与可导性"></a>连续性与可导性</h1><p>如果函数在x0处可导，则函数在x0处连续</p><p>但是在<code>点0</code>处连续，但是在<code>x0</code>处不一定可导，例如<code>y=|x|</code>这个函数的图像是一个<strong>V字形</strong>，而且在原点也没有切线</p><h1 id="导数的运算"><a href="#导数的运算" class="headerlink" title="导数的运算"></a>导数的运算</h1><ul><li>$[f(x)±g(x)]’=[f(x)]’±[g(x)]’$</li></ul><p>设 $u=u(x),v=v(x)$ </p><ul><li>$(uv)’=u’v+uv’</li><li>$(\frac{u}{v})’=\frac{u’v-uv’}{v^2} (v(x)≠0)$ </li><li>$[cu(x)]’=cu’(x)$ </li></ul><h1 id="反函数求导法则"><a href="#反函数求导法则" class="headerlink" title="反函数求导法则"></a>反函数求导法则</h1><p>若函数 $x=f(y)$ 在区间I内单调可导，且 $f’(y)≠0$  ，则其反函数 $y=f^{-1}(x)$ 在区间 $I_x={x|x=f(y),y∈I_y}$ 内也可导，且<br>$$<br>[f^{-1}(x)]’=\frac{1}{f’(y)} ，也就是原函数导数的倒数<br>$$</p><h1 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h1><p>$$<br>y=f(u),u=g(x),f’(x)=\frac{dy}{dx}=\frac{dy}{du}<em>\frac{du}{dx}=f’(u)</em>g’(x)<br>$$</p><p>复合函数求导，就是<strong>两个函数导数的乘积</strong></p><h1 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h1><p>$$<br>v(t)=\frac{ds}{dt},v=s’\<br>a=\frac{dv}{dt}=\frac{d(\frac{ds}{dt})}{dt},a=(s’)’<br>$$</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果<code>f(x)</code>的导数仍然是<code>x</code>的函数，我们就把<code>y&#39;=f&#39;(x)</code>的导数叫做<code>y=f(x)</code>的<strong>二阶导数</strong>，记作<code>y&#39;&#39;=(y&#39;)&#39;</code>或者 $\frac{d^2y}{dx^2}=\frac{d(\frac{ds}{dt})}{dt}$ </p><p>以此类推n阶导数</p><p>二阶导数以及二阶以上的导数均称为<strong>高阶导数</strong></p><p>函数<code>y=f(x)</code>具有<code>n</code>阶导数，也称<code>f(x)</code>为<strong>n阶可导</strong></p><h1 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h1><p>有三种方法</p><h2 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h2><p>使用数学归纳法</p><h2 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h2><p>待补充</p><h2 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h2><p>莱布尼茨公式（Leibniz）</p><p><code>f(x)</code>,<code>g(x)</code>具有n阶导数，则<br>$$<br>[f(x)*g(x)]^{(n)} =<br>f^{(n)}g + C^1_nf^{(n-1)}g^{‘} + … + C^k_nf^{(n-k)}g^{(k)} + … +fg^{(n)} \<br>C^k_n = \frac{ n(n-1)…(n-k+1) }{k!}<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549521&amp;cid=1005705828" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549521&amp;cid=1005705828</a></li><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705835" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549522&amp;cid=1005705835</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>介值定理</title>
      <link href="/2018/11/30/%E4%BB%8B%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2018/11/30/%E4%BB%8B%E5%80%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>设<code>f(x)</code>在<code>闭区间[a,b]</code>上连续，则对于<code>f(a)</code>和<code>f(b)</code>之间的任一<code>常数C</code>，在<code>开区间(a,b)</code>至少存在一点<code>x0</code>，使得<code>f(x0)=C</code></p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>在<code>闭区间[a,b]</code>上连续的曲线，<code>f(x)</code>肯定和这个范围内的一个直线<code>y=C</code>相交（<code>C</code>为<code>f(a)</code>与<code>f(b)</code>之间的任何一个数）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>零点定理</title>
      <link href="/2018/11/30/%E9%9B%B6%E7%82%B9%E5%AE%9A%E7%90%86/"/>
      <url>/2018/11/30/%E9%9B%B6%E7%82%B9%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>方程f(x)=0的根称作函数f(x)的零点</p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>如果某个函数在区间[a,b]上连续，且f(a)f(b)&lt;0，则在(a,b)区间上至少存在一点x0使得f(x0)=0</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>因为一条连续的曲线，如果他的一头在x轴下方，另一头在x轴上方，那么它肯定和x轴相交，交点也可能不止一个</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>有界性定理</title>
      <link href="/2018/11/30/%E6%9C%89%E7%95%8C%E6%80%A7%E5%AE%9A%E7%90%86/"/>
      <url>/2018/11/30/%E6%9C%89%E7%95%8C%E6%80%A7%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><p>闭区间上连续的函数在该区间上必有界限</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果函数仅仅在开区间连续，或者在闭区间上不连续，则函数不一定存在最大或者最小值，也不一定有界。</p><p>例如tan x函数，虽然在定义域连续，但是无界，也不存在最大最小值。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最大值与最小值定理</title>
      <link href="/2018/11/30/%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2018/11/30/%E6%9C%80%E5%A4%A7%E5%80%BC%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%80%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>设函数在区间<code>I</code>上有定义，存在<code>x0∈I</code>，使得对任一<code>x∈I</code>，均有<br>$$<br>f(x)&lt;=f(x_0), (f(x)&gt;=f(x_0))<br>$$<br>则称f(x0)是函数f(x)在区间I上的最大值（最小值）</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>如果一个函数的最大值与最小值相等，则该函数一定是常数函数</p><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>如果存在一个数，f(x)中任何取值都比这个数大或者小，那么这个数就是f(x)的上限或者下限，而且这个数x0一定在定义域内</p><h1 id="最大值最小值定理"><a href="#最大值最小值定理" class="headerlink" title="最大值最小值定理"></a>最大值最小值定理</h1><p>闭区间上连续函数在该区间上一定存在它的最大值和最小值</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705817</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数的间断点</title>
      <link href="/2018/11/28/%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9/"/>
      <url>/2018/11/28/%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%B4%E6%96%AD%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="不连续的情况"><a href="#不连续的情况" class="headerlink" title="不连续的情况"></a>不连续的情况</h1><ul><li><p>在x=x0没有定义</p></li><li><p>在x=x0有定义，但f(x)在x趋于x0的极限不存在</p></li><li><p>在x=x0有定义，f(x)在x趋于x0的极限存在，但是 $\lim\limits_{x \to x_0 }{f(x)} ≠ f(x_0)$ </p><p><strong>上述三种情况都称作函数f(x)在点x0为不连续，点x0称为不连续点，或者间断点。</strong> </p></li></ul><h1 id="第一类间断点"><a href="#第一类间断点" class="headerlink" title="第一类间断点"></a>第一类间断点</h1><p>$f(x_0^+), f(x_0^-)$  存在 ，则x0为第一类间断点</p><h1 id="可去间断点"><a href="#可去间断点" class="headerlink" title="可去间断点"></a>可去间断点</h1><p>$f(x_0^+) = f(x_0^-)$   ，则x=x0为函数f(x)的可去间断点</p><h1 id="跳跃间断点"><a href="#跳跃间断点" class="headerlink" title="跳跃间断点"></a>跳跃间断点</h1><p>$f(x_0^+) ≠ f(x_0^-)$   ，则x=x0为函数f(x)的跳跃间断点</p><h1 id="第二类间断点"><a href="#第二类间断点" class="headerlink" title="第二类间断点"></a>第二类间断点</h1><p>不属于上面三种情况中的任何一种</p><p>例如根本不存在某个单侧连续的情况</p><p>下面是两个第二类间断点的举例说明</p><h2 id="无穷间断点"><a href="#无穷间断点" class="headerlink" title="无穷间断点"></a>无穷间断点</h2><p>例如：<code>tan x</code>当<code>x=π/2</code>时，该函数值将趋向于无穷大</p><h2 id="震荡间断点"><a href="#震荡间断点" class="headerlink" title="震荡间断点"></a>震荡间断点</h2><p>例如：<code>sin x/1</code>当<code>x=0</code>时，该函数值趋向于<code>2π</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705815" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705815</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数的连续性</title>
      <link href="/2018/11/28/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7/"/>
      <url>/2018/11/28/%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="函数连续性定义1"><a href="#函数连续性定义1" class="headerlink" title="函数连续性定义1"></a>函数连续性定义1</h1><p>当一个变量从初值<code>u1</code>变到终值<code>u2</code>，终值与初值的差<code>u2-u1</code>为<code>u</code>的增量</p><p>增量可以为正负值</p><p>当自变量<code>x</code>从<code>x0</code>变化到 $x_0 + \delta x$ ，函数值从f(x0)变化到 $f(x_0+ \delta x)$ 。函数值增量为 $ \delta y = f(x_0 + \delta x) - f(x_0)$ </p><p>如果 $\lim\limits_{\delta x \to 0 }{\delta y} = \lim\limits_{\delta x \to 0 }{[f(x_0 + \delta x) - f(x_0)]} = 0$ 则称函数<code>y=f(x)</code>在点<code>x0</code>处连续 </p><h1 id="函数连续性定义2"><a href="#函数连续性定义2" class="headerlink" title="函数连续性定义2"></a>函数连续性定义2</h1><p>设函数<code>y=f(x)</code>在点<code>x0</code>的某个邻域内有定义，如果<br>$$<br>\lim\limits_{x \to x_0 }{f(x)} = f(x_0)<br>$$<br>则函数<code>y=f(x)</code>在点<code>x0</code>处连续</p><h1 id="单侧连续"><a href="#单侧连续" class="headerlink" title="单侧连续"></a>单侧连续</h1><p>参考单侧极限证明</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>在区间上每一点都连续的函数，叫做在该区间上的连续函数，或者说函数在该区间上连续.</p><p>如果区间包含端点，那么函数在右端点连续是指左连续，在左端点连续是指右连续. </p><h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><ul><li>基本初等函数在其定义域内是连续的</li><li>一切初等函数在其定义区间内都是连续的（定义区间：包含在定义域内的区间）</li><li>函数在区间上单调且连续，则他的反函数也在对应区间上单调且连续</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705815" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549518&amp;cid=1005705815</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>无穷小的比较</title>
      <link href="/2018/11/28/%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2018/11/28/%E6%97%A0%E7%A9%B7%E5%B0%8F%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="无穷小的比较"><a href="#无穷小的比较" class="headerlink" title="无穷小的比较"></a>无穷小的比较</h1><p>虽然当x趋于0的时候，x，sin x，x^3均为无穷小。</p><p>但是通过图形可以看出：x趋于0的时候，x^3趋于0的速度会更快。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>$\alpha,\beta$是同一个自变量变化过程中的无穷小，且 $\alpha ≠ 0$ ,    $ \lim\limits_{}{\frac{\beta}{\alpha}} $ 表示这一变换过程中的极限</p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha}} $=0，表示 $\beta$ 是比 $\alpha$ 高阶的无穷小。记作$\beta=o(\alpha)$</p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha}} $=无穷，表示 $\beta$ 是比 $\alpha$ 低阶的无穷小。记作$\beta=o(\alpha)$</p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha}} $=0，表示 $\beta$ 是比 $\alpha$ <strong>高阶的无穷小</strong></p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha}} $=c≠0，表示 $\beta$ 和 $\alpha$ 是<strong>同阶无穷小</strong></p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha}} $=1，表示 $\beta$ 和 $\alpha$ 是<strong>等价无穷小</strong>，记作 $\alpha $ ~ $ \beta$ </p><p>如果$ \lim\limits_{}{\frac{\beta}{\alpha^k}} =c≠0 (k≠0)$，表示 $\beta$ 是关于 $\alpha$ 的<strong>k阶无穷小</strong></p><h1 id="等价无穷小的性质"><a href="#等价无穷小的性质" class="headerlink" title="等价无穷小的性质"></a>等价无穷小的性质</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p> $\alpha $ ~ $ \beta$ 的充分必要条件是  $ \beta = \alpha + o(\alpha) $ </p><h2 id="等价无穷小"><a href="#等价无穷小" class="headerlink" title="等价无穷小"></a>等价无穷小</h2><p>设 $\alpha$ ~ $\alpha’$ , $\beta $ ~ $\beta’ $ ，且 $ \lim\limits_{}{\frac{\beta’}{\alpha’}} $ 存在，则 $\lim\limits_{}{\frac{\beta}{\alpha}} = \lim\limits_{}{\frac{\beta’}{\alpha’}} $ </p><p>证明：利用等价无穷小可替换的原则<br>$$<br>\lim\limits_{}{\frac{\beta}{\alpha}} =<br>\lim\limits_{}{\frac{\beta}{\beta’}} ·<br>\lim\limits_{}{\frac{\beta’}{\alpha’}} ·<br>\lim\limits_{}{\frac{\alpha’}{\alpha}} =<br>\lim\limits_{}{\frac{\beta’}{\alpha’}}<br>$$</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>在利用等价无穷小代换求极限时，只有对所求极限中相乘或相除的因式才能用等价无穷小来代替， 而对极限中相加或相减的部分 则不能随意来代替.</strong> </p><p>因为等价无穷定义是从比值得来的，所以只能在乘除中使用</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705806" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705806</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单调有界数列收敛准则</title>
      <link href="/2018/11/28/%E5%8D%95%E8%B0%83%E6%9C%89%E7%95%8C%E6%95%B0%E5%88%97%E6%94%B6%E6%95%9B%E5%87%86%E5%88%99/"/>
      <url>/2018/11/28/%E5%8D%95%E8%B0%83%E6%9C%89%E7%95%8C%E6%95%B0%E5%88%97%E6%94%B6%E6%95%9B%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="准则"><a href="#准则" class="headerlink" title="准则"></a>准则</h1><p>单调有界数列必有极限</p><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p>如果数列单调增加且存在上界，该数列必有极限，否则其会无限增加突破上界</p><p>如果数列单调增加且存在下界，该数列必有极限，否则其会无限增加突破下界</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>收敛数列必有界，但有界数列未必收敛</p><p>例如常数数列，某些周期数列，例如<code>sin x</code>，<code>cos x</code>有界，但是不收敛</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>用于证明<br>$$<br>\lim\limits_{x \to \infty }{(1+\frac{1}{x})^x}=e<br>$$</p><h1 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h1><p>因为 ${ (1+\frac{1}{n})^n }$ 这个数列单调增加且有上界，所以它的极限存在。</p><p>我们定义它的极限为<code>e</code>。为一个无理数，通常叫做<strong>欧拉数</strong><code>（Euler&#39;s number）</code></p><p>可以直接用上述结论证明其他数列极限</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>利用夹逼准则证明函数极限</title>
      <link href="/2018/11/28/%E5%88%A9%E7%94%A8%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99%E8%AF%81%E6%98%8E%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/"/>
      <url>/2018/11/28/%E5%88%A9%E7%94%A8%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99%E8%AF%81%E6%98%8E%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="利用夹逼准则证明函数极限"><a href="#利用夹逼准则证明函数极限" class="headerlink" title="利用夹逼准则证明函数极限"></a>利用夹逼准则证明函数极限</h1><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p>x趋于0时，sin x与x的比值极限为1</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>$$<br>\lim\limits_{n \to 0 }{\frac{sin \ x}{x}} = 1<br>$$</p><h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><p>借助夹逼准则证明：</p><ul><li>找到比这个函数大和小的两个函数，列出等价不等式</li><li>寻找当趋于0时，这两个函数的极限相等</li><li>通过夹逼定则来证明极限</li></ul><h2 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h2><h3 id="找到比这个函数大和小的两个函数"><a href="#找到比这个函数大和小的两个函数" class="headerlink" title="找到比这个函数大和小的两个函数"></a>找到比这个函数大和小的两个函数</h3><img src="/2018/11/28/利用夹逼准则证明函数极限/circle.png" title="单位圆"><p>首先上面这个单位圆（半径为<code>1</code>的圆），有如下关系<br>$$<br>S_\bigtriangleup AOB &lt; S_{扇形} AOB &lt; S_\bigtriangleup AOD<br>$$<br>通过初中学习过的三角函数，可以得知</p><ul><li>$OA=OB=1$</li><li>$sin\ x= \frac{BC}{OB}, BC=sin\ x$</li><li>$cos\ x= \frac{OC}{OB}, OC=cos\ x$</li><li>$tan\ x= \frac{AD}{OA}, AD=tan\ x$</li></ul><p>则分别求出面积之后有关系<br>$$<br>\frac{sin\ x}{2} &lt; \frac{x}{2} &lt; \frac{tan\ x}{2},x∈(0,\frac{\pi}{2})<br>$$</p><h3 id="列出等价不等式"><a href="#列出等价不等式" class="headerlink" title="列出等价不等式"></a>列出等价不等式</h3><p>两边同时除以 $\frac{sin\ x}{2}$ 得到<br>$$<br>1 &lt; \frac{x}{sin\ x} &lt; \frac{1}{cos\ x},x∈(0,\frac{\pi}{2})<br>$$<br>由于在 $x∈(0,\frac{\pi}{2})$ 的情况下，上述式子的三个成员都为正数，所以可以同时倒数，然后修改符号<br>$$<br>cos\ x &lt; \frac{sin\ x}{x} &lt; 1, x∈(0,\frac{\pi}{2})<br>$$</p><h3 id="寻找当趋于0时，这两个函数的极限相等"><a href="#寻找当趋于0时，这两个函数的极限相等" class="headerlink" title="寻找当趋于0时，这两个函数的极限相等"></a>寻找当趋于0时，这两个函数的极限相等</h3><p>又由于三个成员都是偶函数（中间的成员根据<strong>奇奇为偶</strong>的奇偶性质推导），所以他们在 $(0,\frac{\pi}{2})$ 的去心领域也成立 </p><p>由于<br>$$<br>\lim\limits_{n \to 0 }{1} = 1, \lim\limits_{n \to 0 }{cos\ x} = 1<br>$$</p><h3 id="通过夹逼定则来证明极限"><a href="#通过夹逼定则来证明极限" class="headerlink" title="通过夹逼定则来证明极限"></a>通过夹逼定则来证明极限</h3><p>所以根据夹逼准则有<br>$$<br>cos\ x &lt; \frac{sin\ x}{x} &lt; 1,x∈(0,\frac{\pi}{2})<br>$$<br>证毕</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>$$<br>|sin\ x|&lt;=|x|<br>$$</p><p>$$<br>\lim\limits_{n \to 0 }{sin\ x} = 0<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>夹逼准则</title>
      <link href="/2018/11/27/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99/"/>
      <url>/2018/11/27/%E5%A4%B9%E9%80%BC%E5%87%86%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>设数列 ${x_n},{y_n},{z_n}$ 满足：</p><ul><li>存在某个正整数 $n_0$ ，当 $n&gt;n_0$ 时，有 $y_n&lt;=x_n&lt;=z_n$ </li><li>$\lim\limits_{n \to \infty }{y_n} = a, \lim\limits_{n \to \infty }{z_n} = a$  则 $\lim\limits_{n \to \infty }{x_n} = a$ </li></ul><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>当<code>n</code>趋于无穷时，数列<code>yn</code>和<code>zn</code>的极限都为常数<code>a</code>，当<code>xn</code>数列夹在他们之间，那么<code>n</code>趋于无穷的时候<code>xn</code>的极限也为<code>a</code></p><p>可以画图来理解</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>当证明某些函数<code>f(x)</code>的极限时，可以任取两个比他们大或者小的函数，先证明这两个的极限都为某一个值<code>A</code>，然后证明他们分别比<code>f(x)</code>的极限大或小。通过夹逼定则，就可以证明<code>f(x)</code>的极限也为<code>A</code>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549517&amp;cid=1005705805</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>极限的运算法则</title>
      <link href="/2018/11/27/%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/"/>
      <url>/2018/11/27/%E6%9E%81%E9%99%90%E7%9A%84%E8%BF%90%E7%AE%97%E6%B3%95%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><ul><li>有限个无穷小的和是无穷小</li><li>有界函数与无穷小的乘积是无穷小</li></ul><h1 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h1><ul><li>常数与无穷小的乘积是无穷小</li><li>有限个无穷小的乘积是无穷小</li></ul><h1 id="极限四则运算法则"><a href="#极限四则运算法则" class="headerlink" title="极限四则运算法则"></a>极限四则运算法则</h1><p>对极限的四则运算结果等于极限值的四则运算结果</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>当极限做除法时，极限值为0的极限不能做除数。</strong></p><p> $\lim\limits_{}{f(x)} = A,\lim\limits_{}{g(x)} = B,  \lim\limits_{}{\frac{f(x)}{g(x)}} = \frac{A}{B},(B≠0)$ </p><h2 id="推论-1"><a href="#推论-1" class="headerlink" title="推论"></a>推论</h2><p>$$<br>\lim\limits_{n \to \infty }{f(x)} = A , 則有 \lim\limits_{n \to \infty }{[cf(x)]} = c \lim\limits_{n \to \infty }{[f(x)]} = cA<br>$$</p><p>$$<br>\lim\limits_{n \to \infty }{f(x)} = A , 則有 \lim\limits_{n \to \infty }{[f(x)]^n} =  [\lim\limits_{n \to \infty }{f(x)}]^n = A^n<br>$$</p><h1 id="函数可以分解为多项式商的形式"><a href="#函数可以分解为多项式商的形式" class="headerlink" title="函数可以分解为多项式商的形式"></a>函数可以分解为多项式商的形式</h1><p>设 $f(x)=\frac{P(x)}{Q(x)}$ ，其中，P(x)和Q(x)为多项式，则当Q(x0)≠0，有<br>$$<br>\lim\limits_{x \to x_0 }{f(x)} =<br>\frac{ \lim\limits_{x \to x_0 }{P(x)} } { \lim\limits_{x \to x_0 }{Q(x)} } =<br>\frac{P(x_0)}{Q(x_0)} =<br>f(x_0)<br>$$</p><h1 id="复合函数的极限运算法则"><a href="#复合函数的极限运算法则" class="headerlink" title="复合函数的极限运算法则"></a>复合函数的极限运算法则</h1><p>设函数由 $y=f[g(x)]$  由函数 $y=f(u)$ 和 $u=g(x)$ 复合而成，$f[g(x)]$ 在点<code>x0</code>的某一取心邻域内有定义，若 $\lim\limits_{x \to x_0 }{g(x)}=u_0, \lim\limits_{u \to u_0 }{f(u)}=A$，且存在 $\delta_0 &gt; 0$ ，当x属于 $(x_0, \delta_0)$ 的去心邻域时，有 $g(x)≠u_0$ ，则  $\lim\limits_{n \to x_0 }{f[g(x)]} = \lim\limits_{n \to x_0 }{f(u)} = A$    </p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ul><li>此定理的条件是保证x趋于x0的时候， $\lim\limits_{n \to x_0 }{f[g(x)]}$ 的极限存在</li><li>求极限的时候可以依据这个方法进行变量代换</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>$a_0≠0,b_0≠0$ m和n为非负整数时<br>$$<br>\lim\limits_{x \to \infty }<br>{ \frac{ a_0x^m + a_1x^{m-1} + … + a_m }{ b_0x^n + b_1x^{n-1} + … + b_n } } =<br>\left{<br>\begin{array}{rcl}<br>\frac{a_0}{b_0} &amp; &amp; {n=m} \\<br>0 &amp; &amp; {n&gt;m} \\<br>\infty &amp; &amp; {n&lt;m}<br>\end{array} \right.<br>$$</p><p>$$<br>\lim\limits_{x \to \infty }<br>{ \frac{ a_0x^m + a_1x^{m-1} + … + a_m }{ b_0x^n + b_1x^{n-1} + … + b_n } } =<br>\left\{<br>\begin{array}{rcl}<br>\frac{a_0}{b_0} &amp; &amp; {n=m} \\\\<br>0 &amp; &amp; {n&gt;m} \\\\<br>\infty &amp; &amp; {n&lt;m}<br>\end{array} \right.<br>$$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549514&amp;cid=1005705796" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549514&amp;cid=1005705796</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>无穷小与无穷大</title>
      <link href="/2018/11/27/%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/"/>
      <url>/2018/11/27/%E6%97%A0%E7%A9%B7%E5%B0%8F%E4%B8%8E%E6%97%A0%E7%A9%B7%E5%A4%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>函数<code>f(x)</code>当<code>x</code>趋于<code>x0</code>时（或无穷时）极限为<code>0</code>，则称<code>f(x)</code>当<code>x</code>趋于<code>x0</code>时（或无穷时）的无穷小</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>$$<br>\lim\limits_{n \to \infty }{\frac{1}{x}=0}<br>$$</p><p>所以 $\frac{1}{x}$ 是<code>x</code>趋于无穷时的无穷小</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>无穷小本质上是个函数，只有常数<code>0</code>（可以把<code>0</code>看成是值为<code>0</code>的常数函数），或者极限为0的函数是无穷小。</p><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>在自变量<code>x</code>的同一变化过程中，函数<code>f(x)</code>有极限<code>A</code>的充分必要条件是：<code>f(x)=A+a(x)</code>，其中a(x)是无穷小。</p><h1 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>函数<code>f(x)</code>当<code>x</code>趋于<code>x0</code>时（或无穷时）其绝对值<code>|f(x)|</code>无限增大，则称<code>f(x)</code>当<code>x</code>趋于<code>x0</code>时（或无穷时）的无穷大</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>$$<br>\lim\limits_{n \to \infty }{x= \infty}<br>$$</p><p>所以 $\frac{1}{x}$ 是x趋于无穷时的无穷小</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>如果仅仅是 $ \lim\limits_{n \to x_0^+ }{x= \infty} $， $ \lim\limits_{n \to x_0^- }{x= \infty} $ 两种情况，则<code>x=x0</code>仅仅是<code>f(x)</code>图形的<strong>铅直渐近线</strong></p><h2 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h2><p>在自变量x的同一变化过程中</p><ul><li>如果<code>f(x)</code>是无穷大，则 $\frac{1}{f(x)}$ 是无穷小</li><li>如果<code>f(x)</code>是无穷小且不等于0，则 $\frac{1}{f(x)}$ 是无穷大</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549514&amp;cid=1005705796" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549514&amp;cid=1005705796</a></li></ul><p># </p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数与极限</title>
      <link href="/2018/11/26/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
      <url>/2018/11/26/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><p>$\lim\limits_{n \to \infty }{x_n=a}$ ，即$\lim\limits_{n \to \infty }{f(n)=a}$</p><p>表示当<code>n</code>趋于无穷时，<code>f(n)</code>无限接近于确定的数<code>a</code></p><p>表示任取一个 $\varepsilon$ ，存在 <code>N&gt;0</code>，当 <code>n&gt;N</code>，有 $|f(n)-a|&lt; \varepsilon$ </p><h1 id="极限的两种情况"><a href="#极限的两种情况" class="headerlink" title="极限的两种情况"></a>极限的两种情况</h1><ul><li>当x趋于一个常数x0的时候（自变量趋于有限值）</li><li>当x趋于无穷的时候（自变量趋于无穷大）</li></ul><h2 id="自变量趋于有限值"><a href="#自变量趋于有限值" class="headerlink" title="自变量趋于有限值"></a>自变量趋于有限值</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当<code>x0</code>在某一取心邻域内有定义，如果存在常数<code>A</code>，任取 $\varepsilon &gt; 0$，$\delta &gt; 0$ ，当 $0&lt;|x-x0|&lt;\delta$  ，有  $ |f(x)-a| &lt; \varepsilon $</p><p>，那么称常数<code>A</code>为<code>f(x)</code>当x趋于<code>x0</code>时的极限。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>首先假设 $\varepsilon &gt; 0$，$\delta &gt; 0$ ，表示任取两个的数字，第一个表示函数值在一个很小的范围内，第二个表示函数自变量在一个很小的范围内。只要自变量在这个范围内，使得函数取值减去某一个极限值都小于另一个很小的数字，那么都可以认为只要自变量取到0，这个函数取值减去某一个极限值的结果也可以取到0，也就是这个函数取值的极限可以取到a这个极限值。</p><p>如果实在无法理解这种极限方式，可以类比数学归纳法来理解，数学归纳法本质上也是由局部情况推导到全局情况。极限也是如此，通过一个很小的局部情况，推导到自变量完全取到0时的函数结果。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>x趋于x0时函数是否有极限，和函数自变量在x0是否有定义无关。因为函数的极限可以是函数值趋向于某个数，而不是函数值达到某个数。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>如果要证明某个函数当x趋于x0的时候极限是否等于另一个极限值，可以用定义来证明。</p><p>只要取好 $\delta $ 这个值，然后根据定义来计算。使得当 $0&lt;|x-x0|&lt;\delta$，分别带入命题中的<code>f(x)</code>和<code>a</code>的值  ，有  $ |f(x)-a| &lt; \varepsilon $ 则证明完毕。</p><h3 id="单侧极限"><a href="#单侧极限" class="headerlink" title="单侧极限"></a>单侧极限</h3><p>前面提到了证明极限的时候，要通过将自变量设置为 $0&lt;|x-x0|&lt;\delta$ ，这里有绝对值，表示自变量是某个常数的取心邻域。</p><p>但是由于某些情况下，自变量只能在该领域的左边或者右边取值，所以这个函数可能只存在单侧极限。</p><p>如果两个单侧极限中任意一个不存在，或者两个单侧极限存在但不相等，则该函数在x0处不存在极限。</p><p>单侧极限分为左极限和右极限。</p><h4 id="左极限"><a href="#左极限" class="headerlink" title="左极限"></a>左极限</h4><p>$ - \delta &lt; x-x0 &lt; 0$ 的情况下，按照极限定义来证明 </p><h4 id="右极限"><a href="#右极限" class="headerlink" title="右极限"></a>右极限</h4><p>$ 0 &lt; x-x0 &lt; \delta$ 的情况下，按照极限定义来证明 </p><h2 id="自变量趋于无穷大"><a href="#自变量趋于无穷大" class="headerlink" title="自变量趋于无穷大"></a>自变量趋于无穷大</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>当<code>|x|</code>大于某一正数时有定义，如果存在常数<code>A</code>，任取 $\varepsilon &gt; 0$， 存在<code>X&gt;0</code>，当 $0|x|&lt;X$  ，有  $ |f(x)-a| &lt; \varepsilon $</p><p>，那么称常数<code>A</code>为<code>f(x)</code>当x趋于<code>x0</code>时的极限。</p><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p><code>x</code>大于某个很大的数之后，<code>f(x)</code>的取值都大于某个常数，那么可以推导出当<code>x</code>趋于无穷打的时候，<code>f(x)</code>的取值也是某个无穷大的数。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>如果要证明某个函数当x趋于无穷的时候极限是否等于另一个极限值，可以用定义来证明。</p><p>只要取好 $X$ 这个值，然后根据定义来计算。使得当 $|x|&lt;X$ ，分别带入命题中的<code>f(x)</code>和<code>a</code>的值  ，有  $ |f(x)-a| &lt; \varepsilon $ 则证明完毕。</p><p>### </p><h1 id="函数极限的性质"><a href="#函数极限的性质" class="headerlink" title="函数极限的性质"></a>函数极限的性质</h1><h2 id="函数极限唯一性"><a href="#函数极限唯一性" class="headerlink" title="函数极限唯一性"></a>函数极限唯一性</h2><p>如果某个函数极限存在，那么这个极限唯一</p><h2 id="函数极限的局部有界性"><a href="#函数极限的局部有界性" class="headerlink" title="函数极限的局部有界性"></a>函数极限的局部有界性</h2><p>如果某个函数极限存在，那么存在某个大于0的常数M，使得f(x)的绝对值小于M。也就是说，函数在全局有极限，那么在局部也有界。</p><h2 id="函数极限的局部保号性"><a href="#函数极限的局部保号性" class="headerlink" title="函数极限的局部保号性"></a>函数极限的局部保号性</h2><p>当某个函数趋于x0时的极限为A，A&gt;0（或A&lt;0），使得$0&lt;|x-x0|&lt;\delta$时，有f(x)&gt;0（或f(x)&lt;0）</p><h2 id="函数极限与数列极限的关系"><a href="#函数极限与数列极限的关系" class="headerlink" title="函数极限与数列极限的关系"></a>函数极限与数列极限的关系</h2><p>若函数极限存在，${x_n}$ 为函数f(x)的任一收敛于x0的数列，且xn≠x0，那么 ${f(x_n)}$ 必定收敛，且他们的极限一致</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>同济大学高等数学</li><li><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549513&amp;cid=1005705788" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549513&amp;cid=1005705788</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>函数</title>
      <link href="/2018/11/26/%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/26/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>设数集$D \subset R$, 如果对D中每个数x，变量 y 按照一定法则在 R 中有唯一确定的数值与之对应， </p><p>则称 y 是 x 的函数,记为<br>$$<br>f=f(x), x∈D<br>$$<br>其中 x 称为自变量, y 称为因变量, D 称为定义域， 记作$D_f$,即$D_f = D$. </p><p>函数值 f (x) 的全体所构成的集合称为函数 f 的值域, 记作 $R_f$ 或 $f(D)$ ,即<br>$$<br>R_f = f(D) = {y|y=f(x), x∈D }<br>$$</p><h1 id="函数记号"><a href="#函数记号" class="headerlink" title="函数记号"></a>函数记号</h1><p>指的是$f(x)中的$ $f$ </p><p>它可以可使用其他字母表示</p><p>也可以直接用因变量的记号来表示，例如 $y=y(x)$ </p><h1 id="定义域"><a href="#定义域" class="headerlink" title="定义域"></a>定义域</h1><p>函数的定义域指的是自变量的取值范围</p><p>定义域有两种：</p><ul><li>自然定义域</li><li>实际定义域</li></ul><h2 id="自然定义域"><a href="#自然定义域" class="headerlink" title="自然定义域"></a>自然定义域</h2><p>使表达式有意义的一切实数所组成的集合</p><p>此时，函数可以只可以用 $y=f(x)$ 表达</p><h2 id="实际定义域"><a href="#实际定义域" class="headerlink" title="实际定义域"></a>实际定义域</h2><p>指的通过实际问题的数学模型确定的，例如自由落体运动中物体下落距离公式 $s = \frac{1}{2} gt^2$ ，</p><p>这里 t 取任何值这个表达式都能成立。但是从问题的数学模型来看，时间是不能为负数的，所以他的实际的定义域 为$D = [0,T]$. </p><h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1><p>点集<br>$$<br>C = {(x,y)|y=f(x), x∈D }<br>$$<br>为函数 $y=f(x)$ 的图形 </p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><ul><li>函数的有界性 </li><li>函数的单调性 </li><li>函数的奇偶性 </li><li>函数的周期性 </li></ul><h2 id="函数的有界性"><a href="#函数的有界性" class="headerlink" title="函数的有界性"></a>函数的有界性</h2><p>函数定义域中，任何一个数字都小于某个数<code>max</code>，则<code>max</code>为该函数的上界</p><p>函数定义域中，任何一个数字都大于某个数<code>min</code>，则<code>min</code>为该函数的下界</p><p>两种情况都不存在，则该函数无界</p><h2 id="函数的单调性"><a href="#函数的单调性" class="headerlink" title="函数的单调性"></a>函数的单调性</h2><p>某个属于定义域内的区间<code>I</code>，若<code>I</code>中任意两个点<code>x1</code>和<code>x2</code>，恒有 $f(x1)&lt;f(x2)$ ，这函数 $f(x)$ 在区间<code>I</code>内<strong>单调增加</strong></p><p>某个属于定义域内的区间<code>I</code>，若<code>I</code>中任意两个点<code>x1</code>和<code>x2</code>，恒有 $f(x1)&gt;f(x2)$ ，这函数 $f(x)$ 在区间<code>I</code>内<strong>单调减少</strong></p><h2 id="函数的奇偶性"><a href="#函数的奇偶性" class="headerlink" title="函数的奇偶性"></a>函数的奇偶性</h2><p>条件：<strong>定义域关于原点对称</strong></p><p>对于任意属于定义域内的数<code>x</code>，$f(-x)=-f(x)$恒成立，则函数 $f(x)$ 为<strong>奇函数</strong></p><p>对于任意属于定义域内的数<code>x</code>，$f(-x)=f(x)$恒成立，则函数 $f(x)$ 为<strong>偶函数</strong></p><p>两种情况都不存在，则该函数为非奇非偶函数</p><h2 id="函数的周期性"><a href="#函数的周期性" class="headerlink" title="函数的周期性"></a>函数的周期性</h2><p>对于任意属于定义域<code>D</code>内的数<code>x</code>，若存在一个正数<code>T</code>，该正数<code>T</code>满足 $x±T ∈D$  ，$f(x+T)=f(x)$恒成立，则函数 $f(x)$ 为<strong>周期函数</strong>，<code>T</code>为它的最小正周期。</p><p><strong>并非所有函数都有最小正周期，例如狄利克雷函数</strong></p><h1 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h1><p>以下五类统称<strong>基本初等函数</strong></p><ul><li>冥函数： $y=x^a   (a∈R) $</li><li>指数函数： $y=a^x   (a&gt;0,a≠1) $</li><li>对数函数：$y=log_ax  (a&gt;0,a≠1) $ ，特别地，当 $a=e$ ，记作 $y=ln \ x$</li><li>三角函数：$y=sin \ x $ ，$y=cos \ x $ ，$y=tan \ x $ ，$y=cot \ x $ ， $y=sec \ x = \frac{1}{cos \ x} $ ， ，$y=csc \ x = \frac{1}{sin \ x} $</li><li>反三角函数：$y=arcsin \  x $ ， $y=arccos \  x $ ，  $y=arctan \  x $ ，  $y=arccot \  x $ ，  </li></ul><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>由<strong>常数和基本初等函数经过有限次的四则运算和有限次的函数复合步骤所构成的并可用一个式子表示的函数</strong>，称为初等函数</p><h1 id="几种特殊函数"><a href="#几种特殊函数" class="headerlink" title="几种特殊函数"></a>几种特殊函数</h1><h2 id="常数函数"><a href="#常数函数" class="headerlink" title="常数函数"></a>常数函数</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>$$<br>y=C \quad D=(-无穷,+无穷) \quad R_f={C}<br>$$</p><h3 id="图形-1"><a href="#图形-1" class="headerlink" title="图形"></a>图形</h3><p>平行于x轴的直线</p><h2 id="绝对值函数"><a href="#绝对值函数" class="headerlink" title="绝对值函数"></a>绝对值函数</h2><h3 id="表达式-1"><a href="#表达式-1" class="headerlink" title="表达式"></a>表达式</h3><p>$$<br>y=C \quad D=(-无穷,+无穷) \quad R_f={0,+无穷}<br>$$</p><h3 id="图形-2"><a href="#图形-2" class="headerlink" title="图形"></a>图形</h3><p>一个V</p><h2 id="符号函数"><a href="#符号函数" class="headerlink" title="符号函数"></a>符号函数</h2><h3 id="表达式-2"><a href="#表达式-2" class="headerlink" title="表达式"></a>表达式</h3><p>$$<br>y=sgn \  x =<br>\left{<br>\begin{array}{rcl}<br>1 &amp; &amp; {x&gt;0}\<br>0 &amp; &amp; {x=0}\<br>-1 &amp; &amp; {x&lt;0}<br>\end{array} \right.<br>$$</p><h3 id="图形-3"><a href="#图形-3" class="headerlink" title="图形"></a>图形</h3><p>左边是一个位于第三象限  $y=-1$ 的直线，右边是一个位于第一象限 $y=1$ 的直线</p><h2 id="取整函数"><a href="#取整函数" class="headerlink" title="取整函数"></a>取整函数</h2><h3 id="表达式-3"><a href="#表达式-3" class="headerlink" title="表达式"></a>表达式</h3><p>$$<br>y=[x]<br>$$</p><p>注意：取整并不是四舍五入，而是向下取整，也就是取<strong>不小于<code>x</code>的最大整数</strong>。类似于编程语言中的<code>floor()</code>函数</p><p>例如：</p><ul><li>[3.5]=3</li><li>[0.5]=0</li><li>[-3.5]=4</li></ul><h3 id="图形-4"><a href="#图形-4" class="headerlink" title="图形"></a>图形</h3><p>阶梯状，0-1的高度为0，1-2的高度为1。</p><h2 id="狄利克雷函数（Dirichlet）"><a href="#狄利克雷函数（Dirichlet）" class="headerlink" title="狄利克雷函数（Dirichlet）"></a>狄利克雷函数（Dirichlet）</h2><h3 id="表达式-4"><a href="#表达式-4" class="headerlink" title="表达式"></a>表达式</h3><p>$$<br>D(x) =<br>\left{<br>\begin{array}{rcl}<br>1 &amp; &amp; {x∈Q}\<br>0 &amp; &amp; {x∈Q^c}<br>\end{array} \right.<br>$$</p><h3 id="图形-5"><a href="#图形-5" class="headerlink" title="图形"></a>图形</h3><p><strong>狄利克雷函数无法用图形表示</strong></p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p><strong>可以通过定义证明狄利克雷函数是周期函数，但是没有最小正周期。</strong></p><h1 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h1><p>自变量在不同变化范围中，对应法则用不同的式子来表示的函数 </p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>同济大学高等数学</p></li><li><p><a href="https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549513&amp;cid=1005705787" target="_blank" rel="noopener">https://www.icourse163.org/learn/TONGJI-53004?tid=1003173009#/learn/content?type=detail&amp;id=1004549513&amp;cid=1005705787</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>设计模式总结</title>
      <link href="/2018/11/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener">软件工程</a>中，<strong>设计模式</strong>（design pattern）是对<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88" target="_blank" rel="noopener">软件设计</a>中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA" target="_blank" rel="noopener">埃里希·伽玛</a>（Erich Gamma）等人在1990年代从<a href="https://zh.wikipedia.org/wiki/%E5%BB%BA%E7%AD%91%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">建筑设计</a>领域引入到<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">计算机科学</a>的。</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>优化代码的修改和版本迭代。以增强软件设计面对并适应变化的能力。使得在软件需求不断变化的时候，仍然能够更加高效地在编程代码中实现。</p><p>增加代码的重用性和可维护性。使得在增加或者修改新功能的时候，可以不用大幅度修改原有的代码，而是可以复用以前的老代码，或者仅仅是简单的修改一些参数和配置。</p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。</p><h1 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h1><p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p><p><strong>对接口编程而不是对实现编程。</strong></p><p><strong>优先使用对象组合而不是继承。</strong></p><h1 id="设计模式6大原则"><a href="#设计模式6大原则" class="headerlink" title="设计模式6大原则"></a>设计模式6大原则</h1><h2 id="1、开闭原则（Open-Close-Principle）"><a href="#1、开闭原则（Open-Close-Principle）" class="headerlink" title="1、开闭原则（Open Close Principle）"></a>1、开闭原则（Open Close Principle）</h2><p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h2 id="2、里氏代换原则（Liskov-Substitution-Principle）"><a href="#2、里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏代换原则（Liskov Substitution Principle）"></a>2、里氏代换原则（Liskov Substitution Principle）</h2><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h2 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><h2 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h2><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h2 id="5、迪米特法则，又称最少知道原则（Demeter-Principle）"><a href="#5、迪米特法则，又称最少知道原则（Demeter-Principle）" class="headerlink" title="5、迪米特法则，又称最少知道原则（Demeter Principle）"></a>5、迪米特法则，又称最少知道原则（Demeter Principle）</h2><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h2><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）中所提到的：总共有 <strong>23 种设计模式</strong>。</p><p>这些模式可以分为三大类：</p><ul><li>创建型模式（Creational Patterns）</li><li>结构型模式（Structural Patterns）</li><li>行为型模式（Behavioral Patterns）</li></ul><h1 id="创建型模式（5种）"><a href="#创建型模式（5种）" class="headerlink" title="创建型模式（5种）"></a>创建型模式（5种）</h1><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>原始的对象创建是通过new关键词实现，将类的创建过程交给用户自己操作。通过工厂模式，将类的创建过程交给另一个工厂类（FactoryClass），通过调用该工厂类的某个方法来完成。他的典型用途有“单例模式”。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>上述的工厂类本身又是由另一个超级工厂创建出来的。主要是为了对创建的类进行更细化的分类。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一个类只有一个实例。主要应用在某些只需要一个类就能完成的功能。例如数据库的连接句柄，可以共用。（但是共用的时候要注意线程安全问题）。在多线程环境，也要注意加锁，防止由于两个线程读取到的内部存储实例的变量状态不一致，导致单例工厂方法错误的创建多个线程。在Java多线程环境下有synchronized同步锁。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>在一个类中，通过一系列的集合对象，将多个类的实例对象存储到一个成员中。例如电商网站的订单系统，就是将多个商品实体类的实例对象存储到一个订单对象中，然后可以进行下单方法，计算总价方法等等操作。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>将一个已经实例化的对象直接克隆出另一个一模一样的对象实例。通过这种方法来创建对象开销比较小。因为只需要拷贝成员（深拷贝和浅拷贝），无需进行开销较大的构造方法执行操作。例如老版本ECMAScript（JavaScript）的原型创建对象。</p><h1 id="结构型模式（8种）"><a href="#结构型模式（8种）" class="headerlink" title="结构型模式（8种）"></a>结构型模式（8种）</h1><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口通过一个适配器类转换成另一个借口。例如PHP PDO就是一个适配器类，将MySQL和Oracle数据库不同的操作接口适配成统一的PDO操作接口。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>某个类的方法需要调用另一个类的方法，那么预留一个参数为该类的类型。调用的时候根据业务逻辑的不同，调用不同的类。这种方法将两个类桥接，实现功能的灵活调用。</p><h2 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h2><p>通过使用不同的标准（Criteria）和它们的结合来过滤某些对象。例如电商网站搜索功能中的只显示包邮信息，只显示价格区间在xxx-xxx之间的商品对象等等。</p><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>在某个对象的成员里面再组合另一个对象，然后调用的时候可以通过这个成员来调用另一个被组合进该对象的对象。例如Windows目录树，电商网站的商品分类目录等等。</p><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>通过在该类外部再包装一个类，这个类给原始类新增了一些功能，但是并不改变原有类的行为。就像装饰一样将新的行为方法增加上去。例如Python的装饰器</p><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>系统原有类的调用比较复杂，现在通过一个统一的外观门面类（Facade）来封装原本复杂的操作类。例如PHP的Laravel框架中的Redis缓存和数据库操作，原本需要先连接句柄，设置一些连接参数，然后在调用各种方法才能完成的操作，通过一个Cache门面类的set，get静态方法直接调用，简化了对原有类的方法调用。</p><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>系统中可能会实例化大量的类，这些实例化对象的属性可能都不一样，而某些对象实例可能会重用，因此在第一次创建的时候将他们缓存起来，下次如果还需要调用属性匹配的对象实例，先判断是否有缓存，有就可以直接取出，没有则先创建，然后写缓存，然后再返回。类似于WEB开发中利用Redis做MySQL数据库缓存。</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>某些类的某些成员或者方法需要进行一些校验，或者过滤操作。那么不能让开发者直接访问这个类，需要另外写一个代理类，通过这个代理类去操作原始类。而这个代理类的内部有鉴权，校验，过滤等操作。</p><h1 id="行为型模式（12种）"><a href="#行为型模式（12种）" class="headerlink" title="行为型模式（12种）"></a>行为型模式（12种）</h1><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>行为设计模式，为请求设置一系列的接受者，这些接受者依次接受请求，并且按照链往下传递。类似于Java JSP的filter，Struts的拦截器，Laravel的中间件。Nginx中也有用到类似技术。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将某些操作封装成一个类，对外只暴露execute方法。另一个专门负责执行的类，只负责调用这些类的execute方法，至于具体执行什么操作，由传入的命令类来决定。例如按钮可以绑定一个点击事件，至于点击之后执行什么操作，由绑定的命令类来决定。</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>定义一个语言和一个解释器类。这个解释器类解析语句，执行相应的操作。对于某些问题发生的频率比较高，那么值得编写一个解释器类来解释语句从而解决问题。例如SQL，正则表达式。</p><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>某些类内部会存储一个聚合对象（包含多个成员的一系列对象，例如线性表），不同的聚合对象存储方式，遍历他的底层操作可能不一样。但是对外暴露一个迭代器方法，使得对于任何聚合对象，都可以使用统一的迭代器操作来遍历。例如JAVA的iterator接口具有hasNext，next方法。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>当多个类耦合在一起，形成了网状的耦合，可以将两个类的功能分离。通过在其中一个类中，直接调用另一个类，调用时传入目标对象，实现解耦合，例如PHP框架中，返回HTML或者XML或者JSON，就让控制器调用不同的response对象。</p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>将一个类当前的状态全部保存，在以后需要的时候再调用。具体场景有编辑草稿功能。代码中的应用有PHP的serialize序列化操作。（但是要注意的是，代码中的序列化保存的只是类的属性，而不是行为方法，如果需要调用行为，还需要原始类代码在运行时上下文中）。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>某个对象的属性修改，将通过一个广播方法告知其他对象，让其他对象观察到这个这个状态的改变，从而作出响应。在Yii框架中的事件系统就有类似的行为。例如买家发起退货请求，同时要将这个请求发送给物流商，卖家以及淘宝官方，还有后台的日志，大数据统计系统等等。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>一个类的内部状态修改之后，将返回不同的类。例如淘宝订单状态变成退货状态之后，需要改用退货类，而不是原始的已购买宝贝类。</p><h2 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h2><p>某些情况下，某些对象可能为null，此时这类空对象需要一个默认行为。例如歌曲播放APP中如果一个歌曲的歌手为空，那么应该显示为“佚名”，显示佚名这个操作就是空对象的一个默认行为。</p><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>某些对数据结构的操作接口相同，只是内部的算法不一样。因此将这一系列的算法封装成单独的策略类。在不同的行为驱动下，调用不同的算法策略。例如某个场景，我们已知整个数列大致有序，现在希望把它排序成整体有序，我们就可以使用最优情况下时间复杂度低的插入排序策略。如果我们对排序空间没有要求，但是对速度要求高，我们可以使用归并排序策略等等。</p><h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><p>某个算法中的小步骤都是相同的，只是外部的一些调用不同。因此可以把这个算法封装成一个模板类（与C++中的模板概念无关），这个模板类内部有一些步骤相同的方法代码。而开发者具体实现的时候，不需要（也不能修改，因为模板类会把这些方法定义为final修饰）修改和关心这些相同的小步骤的实现细节，只需要调用就好。例如排序算法中通常都有交换（swap）这个操作，因此可以将所有排序算法都封装一个模板类，模板类内定义一个被final修饰的swap方法。开发者在具体实现某个排序算法的时候可以直接继承这个模板类，然后调用swap算法即可。不需要再每个算法的具体实现类中手动实现一遍swap算法。</p><p>某些算法的宏观调用是一样的，只是内部的细节操作不一样。因此将这些宏观调用方法封装成一个模板类。在具体实现的时候，只需要继承模板类，然后实现底层的方法。例如一个视频播放插件，对于每个视频来说都有播放，暂停等操作，也就是这个类的execute方法中都会先后调用play()和pause()方法，但是不同的视频格式，对于play()这个操作来说，他具体的解码算法也不一样，所以需要底层开发者具体实现不同的play()方法。但是上层调用者只需要调用execute即可，无需关心底层的play()方法具体是什么算法。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>定义一系列的访问者对象。开发者调用不同类型的访问者对象，受访者对象将执行不同的行为方法。访问者模式主要利用了代码中的重载override特性。例如支付宝收银台外，部调用的都是buy()方法，只是传入的访问者参数对象类型不一样。选择银行卡支付，那么访问者就是银行卡类，也就是buy(BankCard)，选择支付宝余额支付，访问者就是支付宝余额，也就是buy(AlipayBalance)。然后每个不同的访问者类型，将调用不同的后端逻辑，例如BankCard访问者将调用银行卡扣款的业务逻辑，支付宝余额就调用支付宝余额的扣款逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学归纳法</title>
      <link href="/2018/11/25/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/"/>
      <url>/2018/11/25/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p><strong>数学归纳法</strong>（<strong>Mathematical Induction</strong>、<strong>MI</strong>、<strong>ID</strong>）是一种<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">数学证明</a>方法，通常被用于证明某个给定<a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E9%A2%98" target="_blank" rel="noopener">命题</a>在整个（或者局部）<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E6%95%B0" target="_blank" rel="noopener">自然数</a>范围内成立。除了自然数以外，<a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89" target="_blank" rel="noopener">广义</a>上的数学归纳法也可以用于证明一般<a href="https://zh.wikipedia.org/wiki/%E8%89%AF%E5%9F%BA%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener">良基</a>结构，例如：<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E8%AE%BA" target="_blank" rel="noopener">集合论</a>中的<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E9%9B%86%E5%90%88%E8%AE%BA" target="_blank" rel="noopener">树</a>)。这种广义的数学归纳法应用于<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E9%82%8F%E8%BC%AF" target="_blank" rel="noopener">数学逻辑</a>和<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>领域，称作<a href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%BD%92%E7%BA%B3%E6%B3%95" target="_blank" rel="noopener">结构归纳法</a>。</p><p>虽然数学归纳法名字中有“归纳”，但是数学归纳法并非<a href="https://zh.wikipedia.org/wiki/%E4%B8%A5%E8%B0%A8%E6%80%A7_(%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">不严谨</a>)的<a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E7%BA%B3%E6%8E%A8%E7%90%86" target="_blank" rel="noopener">归纳推理法</a>，它属于完全<a href="https://zh.wikipedia.org/wiki/%E5%9A%B4%E8%AC%B9" target="_blank" rel="noopener">严谨</a>的<a href="https://zh.wikipedia.org/wiki/%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86" target="_blank" rel="noopener">演绎推理法</a>。事实上，所有<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E8%AD%89%E6%98%8E" target="_blank" rel="noopener">数学证明</a>都是演绎法。</p></blockquote><blockquote><p>最简单和常见的数学归纳法是证明当<em>n</em>等于任意一个自然数时某命题成立。证明分下面两步：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/92/Dominoeffect.png/200px-Dominoeffect.png" alt="img"></p><p>骨牌一个接一个倒下，就如同一个值到下一个值的过程。</p><ol><li>证明当<em>n</em> = 1时命题成立。</li><li>证明如果在<em>n</em> = <em>m</em>时命题成立，那么可以<strong>推导</strong>出在<em>n</em> = <em>m</em>+1时命题也成立。（<em>m</em>代表任意自然数）</li></ol><p>这种方法的原理在于：首先证明在某个起点值时命题成立，然后证明从一个值到下一个值的过程有效。当这两点都已经证明，那么任意值都可以通过反复使用这个方法推导出来。把这个方法想成<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%95%88%E5%BA%94" target="_blank" rel="noopener">多米诺效应</a>也许更容易理解一些。例如：你有一列很长的直立着的多米诺骨牌，如果你可以：</p><ol><li>证明第一张骨牌会倒。</li><li>证明只要任意一张骨牌倒了，那么与其相邻的下一张骨牌也会倒。</li></ol><p>那么便可以下结论：所有的骨牌都会倒下。</p><p>这种方法的原理在于：首先证明在某个起点值时命题成立，然后证明从一个值到下一个值的过程有效。当这两点都已经证明，那么任意值都可以通过反复使用这个方法推导出来。把这个方法想成<a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%95%88%E5%BA%94" target="_blank" rel="noopener">多米诺效应</a>也许更容易理解一些。例如：你有一列很长的直立着的多米诺骨牌，如果你可以：</p><ol><li>证明第一张骨牌会倒。</li><li>证明只要任意一张骨牌倒了，那么与其相邻的下一张骨牌也会倒。</li></ol><p>那么便可以下结论：所有的骨牌都会倒下。</p></blockquote><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>首先证明 <code>n=1</code> 为真，然后证明 <code>n=k</code> 时为真，<code>n=k+1</code> 也为真</p><p>证明 <code>n=k+1 也为真</code>这个操作需要用到一些技巧，例如等号左右分别转换成另一种形式，然后得到相等的算式。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>假设我们要证明下面这个公式（命题）：</p><p>${\displaystyle 1+2+3+\cdots +n={\frac {n(n+1)}{2}}}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b076bd0ed8170b21f90eab91b748a30e55f55e88" alt="1+2+3+\cdots +n={\frac {n(n+1)}{2}}"></p><p>其中<em>n</em>为任意自然数。这是用于计算前<em>n</em>个自然数的和的简单公式。证明这个公式成立的步骤如下。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><h4 id="第一步-起始步骤"><a href="#第一步-起始步骤" class="headerlink" title="第一步-起始步骤"></a>第一步-起始步骤</h4><p>第一步是验证这个公式在<em>n = 1</em>时成立。我们有左边 = <em>1</em>，而右边 =${\displaystyle {\frac {1(1+1)}{2}}=1}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/04319e808d4581f4576888a17c44177a29cbdad6" alt="{\frac {1(1+1)}{2}}=1">，所以这个公式在<em>n</em> = <em>1</em>时成立。第一步完成。</p><h4 id="第二步-推递步骤"><a href="#第二步-推递步骤" class="headerlink" title="第二步-推递步骤"></a>第二步-推递步骤</h4><p>第二步我们需要证明如果<strong>假设</strong> <code>n = m</code>时公式成立，那么可以<strong>推导</strong>出<code>n = m+1</code>时公式也成立。证明步骤如下。</p><p>我们先假设<code>n = m</code>时公式成立。即</p><p>${\displaystyle 1+2+\cdots +m={\frac {m(m+1)}{2}}}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/abc1d50a48280dcd1374571d97ecbbb13e436898" alt="1+2+\cdots +m={\frac {m(m+1)}{2}}">（等式1）</p><p>然后在等式等号两边分别加上<em>m</em> + 1得到</p><p>${\displaystyle 1+2+\cdots +m+(m+1)={\frac {m(m+1)}{2}}+(m+1)}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a217ccae1ab7ea3909ac3be528a0151a78a346fc" alt="1+2+\cdots +m+(m+1)={\frac {m(m+1)}{2}}+(m+1)">（等式2）</p><p>这就是<em>n</em> = <em>m</em>+1时的等式。我们现在需要根据等式1证明等式2成立。通过因式分解合并，等式2的右手边</p><p>${\displaystyle ={\frac {m(m+1)}{2}}+{\frac {2(m+1)}{2}}={\frac {(m+2)(m+1)}{2}}={\frac {(m+1)(m+2)}{2}}={\frac {(m+1)[(m+1)+1]}{2}}.}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1d257b49479295ce7d579e239735a22cbe435337" alt="={\frac {m(m+1)}{2}}+{\frac {2(m+1)}{2}}={\frac {(m+2)(m+1)}{2}}={\frac {(m+1)(m+2)}{2}}={\frac {(m+1)[(m+1)+1]}{2}}."></p><p>也就是说</p><p>${\displaystyle 1+2+\cdots +(m+1)={\frac {(m+1)[(m+1)+1]}{2}}}$<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/328bb76c33c74d0cae042af939966bf339b40214" alt="1+2+\cdots +(m+1)={\frac {(m+1)[(m+1)+1]}{2}}"></p><p>这样便证明了从P（<em>m</em>） 成立可以推导出P（<em>m</em>+1） 也成立。证明至此完成，结论：对于任意自然数<em>n</em>，P（<em>n</em>） 均成立。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>在这个证明中，归纳推理的过程如下：</p><ol><li>首先证明P(1)成立，即公式在<em>n</em> = 1时成立。</li><li>然后证明从P（<em>m</em>） 成立可以推导出P（<em>m</em>+1） 也成立。（这里实际应用的是演绎推理法）</li><li>根据上两条从P(1)成立可以推导出P（1+1），也就是P(2)成立。</li><li>继续推导，可以知道P（3）成立。</li><li>从P(3)成立可以推导出P(4)也成立。</li><li>不断不断不断的重复推导下一命题成立的步骤。（这就是所谓“归纳”推理的地方）</li><li>我们便可以下结论：对于任意自然数<em>n</em>，P（<em>n</em>） 成立。</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.zhihu.com/question/29458134" target="_blank" rel="noopener">https://www.zhihu.com/question/29458134</a></li><li><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学叙述</title>
      <link href="/2018/11/25/%E6%95%B0%E5%AD%A6%E5%8F%99%E8%BF%B0/"/>
      <url>/2018/11/25/%E6%95%B0%E5%AD%A6%E5%8F%99%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>数学叙述是对一些道理，结论的描述。主要有如下几种形式的分类：</p><h2 id="公理"><a href="#公理" class="headerlink" title="公理"></a>公理</h2><p><strong>公理</strong>分为<strong>逻辑公理</strong>和<strong>非逻辑公理</strong></p><p>公理就是固有的自然规律，是无需证明就可以直接拿来使用的结论。例如<code>1+1=2</code>，它是人类自己在某个特定理论中定义的性质。例如<code>(A ∧ B) → A</code>，它是一种普遍为真的陈述。</p><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><p>是经过受逻辑限制的证明为真的陈述。</p><p>它是已经被证明的数学叙述。</p><h2 id="命题"><a href="#命题" class="headerlink" title="命题"></a>命题</h2><p>命题是一中猜想，假设某个数学叙述为真。</p><p>如果把这个命题证明为真命题，他就是定理。</p><p>猜想是定理的其中一种来源。</p><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>根据已经存在的定理，推导出新的定理。</p><h2 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h2><p>辅助定理，补充定理。</p><p>它是某个定理的证明的一部分叙述。并非主要的结果。</p><h2 id="假说"><a href="#假说" class="headerlink" title="假说"></a>假说</h2><p>根据已知的科学事实和科学原理，对所研究的自然现象及其规律性提出的推测和说明。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%AE%9A%E7%90%86</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%85%AC%E7%90%86</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基尔霍夫电压定律（KVL）</title>
      <link href="/2018/11/24/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E7%94%B5%E5%8E%8B%E5%AE%9A%E5%BE%8B%EF%BC%88KVL%EF%BC%89/"/>
      <url>/2018/11/24/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E7%94%B5%E5%8E%8B%E5%AE%9A%E5%BE%8B%EF%BC%88KVL%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在集中参数电路中，任一时刻沿着任一回路各支路电压的代数和等于0。</p><h1 id="参考方向"><a href="#参考方向" class="headerlink" title="参考方向"></a>参考方向</h1><p>参考方向和回路方向相同时，<code>u</code>取<code>+</code>，否则取<code>-</code>。</p><h1 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h1><p>沿着任一回路，各支路电压降的代数和等于电压升的代数和。</p><p>任意两点的电压为确定值，和计算路径无关。</p><p>网孔上的KVL方程是一组独立方程。（也就是说每个网孔都可以列一个独立方程，有几个网孔就可以列几个独立方程）</p><p>电路的网孔数（KVL独立方程个数）等于<code>b-(n-1)</code>。</p><h1 id="选取独立回路的方法"><a href="#选取独立回路的方法" class="headerlink" title="选取独立回路的方法"></a>选取独立回路的方法</h1><ul><li>选网孔。</li><li>新选的回路中要包含已选回路中没有的支路（这样列出来的方程才是独立的，才可能解出来）。也就是同一条支路不能选两次。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653683&amp;cid=1005912471" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653683&amp;cid=1005912471</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基尔霍夫电流定律（KCL）</title>
      <link href="/2018/11/24/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E7%94%B5%E6%B5%81%E5%AE%9A%E5%BE%8B%EF%BC%88KCL%EF%BC%89/"/>
      <url>/2018/11/24/%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB%E7%94%B5%E6%B5%81%E5%AE%9A%E5%BE%8B%EF%BC%88KCL%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在集中参数电路中，任一时刻流出（或流入）任一节点的支路电流代数和等于0。</p><h1 id="参考方向"><a href="#参考方向" class="headerlink" title="参考方向"></a>参考方向</h1><p>通常规定：流出为<code>+</code>，流入为<code>-</code>。</p><h1 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h1><p>任一时刻，流出任一节点（或闭合边界）电流的代数和等于流入该节点（或闭合边界）电流的代数和。</p><p>借助该推论，在解题的时候，可以直接在闭合电路上画一个圈，圈的边界所有接触到的支路流入电流和流出电流代数和为0。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>在含有<code>n</code>个节点的电路中，任一<code>n-1</code>个节点的KCL方程是一组独立方程，这些节点称为独立节点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653680&amp;cid=1005912465" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653680&amp;cid=1005912465</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何在博客中插入数学公式</title>
      <link href="/2018/11/24/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
      <url>/2018/11/24/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在写理工科的博客或者笔记的时候经常需要插入公式。在word中我们可以使用公式编辑器。但是在 markdown 或者其他传统博客平台，如何插入数学公式呢？</p><p>下面有几种方法介绍给大家</p><h1 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h1><p>目前在博客，或者markdown中书写数学公式，主要使用的是<strong>LaTeX</strong>。</p><blockquote><p><strong>LaTeX</strong> 是一种基于<a href="https://zh.wikipedia.org/wiki/TeX" target="_blank" rel="noopener">TEX</a>的<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E7%89%88" target="_blank" rel="noopener">排版</a>系统，由<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD" target="_blank" rel="noopener">美国</a><a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>家<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener">莱斯利·兰伯特</a>在20世纪80年代初期开发，利用这种格式系统的处理，即使用户没有排版和程序设计的知识也可以充分发挥由TEX所提供的强大功能，不必一一亲自去设计或校对，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">数学</a>公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的<a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E6%8A%80" target="_blank" rel="noopener">科技</a>和数学、物理文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p></blockquote><h1 id="如何在博客中插入数学公式"><a href="#如何在博客中插入数学公式" class="headerlink" title="如何在博客中插入数学公式"></a>如何在博客中插入数学公式</h1><p>传统的HTML是不支持直接解析<strong>LaTeX</strong>数学公式的。我们首先要引入<strong>MathJax</strong>引擎来帮助解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果使用的是<strong>Hexo</strong>博客系统的<strong>NEXT</strong>系列主题，可以直接在配置文件中启用<strong>MathJax</strong>引擎。具体方法如下</p><p>寻找到<code>Third Party Services Settings</code>注释的上下文，在它下文有个<code>MathJax Support</code>注释段，下面就是<code>mathjax</code>配置字段。将<strong>enable</strong>设置为<strong>true</strong>即可。</p><p>在它下面还可以配置CDN源，也就是<strong>MathJax</strong>引擎的脚本路径。</p><p>中国大陆地区推荐使用<code>bootcss</code>的CDN源，地址为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>其他地区推荐使用<code>cloudflare</code>的源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>这里源没有带上协议头，是为了自适应<code>HTTP</code>和<code>HTTPS</code>协议。</p><h1 id="如何以图片的方式插入数学公式"><a href="#如何以图片的方式插入数学公式" class="headerlink" title="如何以图片的方式插入数学公式"></a>如何以图片的方式插入数学公式</h1><p>为了保证更高的兼容性，保证在某些不支持JavaScript的设备或者笔记软件内也能够正常插入数学公式，可能需要将数学公式转换成图片的方式引入。例如Wikipedia维基百科就是这样做的。</p><p>目前有两个公共服务提供在线将数学公式自动转换为图片的服务：Google Chart和forkosh</p><p>在HTML中通过直接引入img标签，src为特定的格式，他们的公共服务器会自动将公式转换成对应的图片输出。</p><h2 id="使用Google-Chart的服务器"><a href="#使用Google-Chart的服务器" class="headerlink" title="使用Google Chart的服务器"></a>使用Google Chart的服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://chart.googleapis.com/chart?cht=tx&amp;chl=在此插入Latex公式&quot; style=&quot;border:none;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="使用forkosh服务器"><a href="#使用forkosh服务器" class="headerlink" title="使用forkosh服务器"></a>使用forkosh服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.forkosh.com/mathtex.cgi?在此处插入Latex公式&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="LaTeX语法"><a href="#LaTeX语法" class="headerlink" title="LaTeX语法"></a>LaTeX语法</h1><p>前面我们只讲到了如何让我们的博客支持这种数学公式，实际上我们还需要了解如何书写语法，让系统解析我们的数学公式。</p><h2 id="语法界限"><a href="#语法界限" class="headerlink" title="语法界限"></a>语法界限</h2><p>LaTeX语法本质上是由普通的英文字符和标点符号组成，如何让解析器知道我当前输入的是普通的英文字符还是用于提供给公式解析器的LaTeX语法呢？我们需要语法界定符，这个语法界定符号就是<strong>美元符号</strong> <strong>$</strong> 。语法界定符需要在首尾都使用。</p><p>界定符号可以双写也可以单写，他们的区别是：双写会另起新的一行显示公式，单写是在行内直接显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$1+2=3$</span><br><span class="line">$$1+2=3$$</span><br></pre></td></tr></table></figure><p>$1+2=3$<br>$$<br>1+2=3<br>$$</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>最简单的公式就是数组的下标和次方的上标表示。</p><p>下标用下划线 <code>_</code> ，上标用脱字符 <code>^</code>。</p><p>他们的顺序不固定，可以先写下标再写上标，也可以先写上标再写下标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$x_1$</span><br><span class="line"></span><br><span class="line">$x_1^2$</span><br><span class="line"></span><br><span class="line">$x^2_1$</span><br></pre></td></tr></table></figure><p>$x_1$<br>$x_1^2$<br>$x^2_1$</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>有的时候我们的求和上标或者下标会出现不止一个数学符号，例如 -1 实际上是由负号和1组成。</p><p>我们需要使用大括号 <code>{}</code> ，将他们包裹起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\int_a^&#123;-b&#125; f(x)dx$</span><br></pre></td></tr></table></figure><p>$\int_a^{-b} f(x)dx$</p><h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac&#123;x+y&#125;&#123;2&#125;$</span><br><span class="line">$\frac&#123;1&#125;&#123;1+\frac&#123;1&#125;&#123;2&#125;&#125;$</span><br></pre></td></tr></table></figure><p>$\frac{x+y}{2}$<br>$\frac{1}{1+\frac{1}{2}}$</p><h2 id="求和、积分"><a href="#求和、积分" class="headerlink" title="求和、积分"></a>求和、积分</h2><p>求和是 <code>\sum</code> ，积分是 <code>\int</code> ，后面再接上标和下标即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$\sum_&#123;k=1&#125;^&#123;n&#125;\frac&#123;1&#125;&#123;k&#125;$</span><br><span class="line"></span><br><span class="line">$\sum_&#123;k=1&#125;^n\frac&#123;1&#125;&#123;k&#125;$</span><br><span class="line"></span><br><span class="line">$\int_a^b f(x)dx$</span><br><span class="line"></span><br><span class="line">$\int_a^b f(x)dx$</span><br></pre></td></tr></table></figure><p>$$\sum_{k=1}^{n}\frac{1}{k}$$$\sum_{k=1}^{n}\frac{1}{k}$<br>$\sum_{k=1}^n\frac{1}{k}$<br>$\int_a^b f(x)dx$<br>$\int_a^b f(x)dx$<br>$\sum_{k=1}^n\frac{1}{k}$<br>$$\int_a^b f(x)dx$$<br>$\int_a^b f(x)dx$</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有其他语法请参考下面的【参考资料】部分。我平时主要用到的就是分数，积分等等了。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.cs.nthu.edu.tw/~cherung/teaching/2009cs5321/link/latex.pdf" target="_blank" rel="noopener">http://www.cs.nthu.edu.tw/~cherung/teaching/2009cs5321/link/latex.pdf</a></li><li><a href="https://zh.wikipedia.org/zh-hans/LaTeX" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/LaTeX</a></li><li><a href="https://blog.csdn.net/xiahouzuoxin/article/details/26478179" target="_blank" rel="noopener">https://blog.csdn.net/xiahouzuoxin/article/details/26478179</a></li><li><a href="https://liam.page/2014/09/08/latex-introduction/" target="_blank" rel="noopener">https://liam.page/2014/09/08/latex-introduction/</a></li><li><a href="http://www.cnblogs.com/houkai/p/3399646.html" target="_blank" rel="noopener">http://www.cnblogs.com/houkai/p/3399646.html</a></li><li><a href="https://juejin.im/post/5a6721bd518825733201c4a2#heading-15" target="_blank" rel="noopener">https://juejin.im/post/5a6721bd518825733201c4a2#heading-15</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路元器件之电容器</title>
      <link href="/2018/11/24/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/11/24/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="电容器的组成"><a href="#电容器的组成" class="headerlink" title="电容器的组成"></a>电容器的组成</h1><img src="/2018/11/24/电路元器件之电容器/capacitor.png" title="电容器的组成结构"><p>电容器是由一个绝缘介质两端接上金属极板组成。</p><p>从广义的角度上来看，也许任何两个金属极板加上中间的绝缘介质都可以视为一个电容。</p><p>例如，教室两边的铝合金窗架和教室中间的空气，也可以视为是一个电容，只不过由于空气这个介质的介电常数太小，并且两个铝合金窗架之间的距离太远，因此当两个铝合金窗架通入直流电时，无法聚集较多的电子。</p><h1 id="电容器的性质"><a href="#电容器的性质" class="headerlink" title="电容器的性质"></a>电容器的性质</h1><p>由于电容器两个极板之间具有绝缘介质，因此电子无法直接穿透电容器流动。</p><p>当电容器接入直流电源时，极板两端带上电压，电压将会使得极板两端分别聚集正负电荷。正负电荷会被互相吸引，开始充电。</p><p>电容器两极板通过导线连接，正负电荷中和，电容器放电。</p><h1 id="库伏特性"><a href="#库伏特性" class="headerlink" title="库伏特性"></a>库伏特性</h1><p>$q=Cu$</p><p>C 为 电容系数。单位 F（法拉）</p><h1 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h1><p>$i=\frac{dq}{dt}= \frac{d(cu)}{dt}= C \frac{du}{dt}$</p><p>线性电容的端口电流与端口电压的时间变化率成正比</p><h1 id="记忆特性"><a href="#记忆特性" class="headerlink" title="记忆特性"></a>记忆特性</h1><p>$u(t)= \frac{q(t)}{C} = \frac{1}{C} \int^t_{-∞} i(t)dt$</p><p>这个公式是电容在任意时刻时，电压的取值。它是由伏安特性的差分方程推导出的积分公式。</p><p>从中可以看出，他在 t 时刻的电压，是由 t 时刻之前所有的电流取值积分后除以电容系数所得。</p><h1 id="功率特性"><a href="#功率特性" class="headerlink" title="功率特性"></a>功率特性</h1><p>$p=ui=Cu \frac{du}{dt} = \frac{d( \frac{Cu^2}{2} )}{dt}$</p><p>根据伏安特性和记忆特性推导出他的功率公式，通过 牛顿-莱布尼茨 定理，推导出功率计算原函数。 </p><h1 id="储能特性"><a href="#储能特性" class="headerlink" title="储能特性"></a>储能特性</h1><p>$w_e = \int^t_{-∞} p(t’)dt’ = \int^t_{-∞} Cu \frac{du}{dt’} dt’ = C \int^t_{-∞} u du = \frac{Cu^2}{2} \begin{vmatrix} u(t)\\u(-∞)\end{vmatrix} $ </p><p>将功率对时间积分，就可以得到电容器的储能值。通过 牛顿-莱布尼茨 公式，可以推导出他的原函数。</p><p>根据该函数可以计算出他在 t 时刻时的储能。</p><h1 id="电容器的性质-1"><a href="#电容器的性质-1" class="headerlink" title="电容器的性质"></a>电容器的性质</h1><ul><li>电容器上任意时刻的电流取决于该时刻电容器两端电压的变化率，与该时刻电容器电压的数值无关。</li><li>电容器电压变化越快，电流越大。即使某个时刻电压为0，也可能有电流。</li><li>当电容器电压为恒定值，电容器相当于开路。电容器有隔断直流的作用。</li><li>任一时刻电容电流为有限值，则电压不能跃变。</li></ul><h1 id="串并联等效"><a href="#串并联等效" class="headerlink" title="串并联等效"></a>串并联等效</h1><h2 id="串联"><a href="#串联" class="headerlink" title="串联"></a>串联</h2><p>根据<strong>串联电流相等，电压相加</strong>的原则，推导电容的串联等效公式</p><p>根据电容伏安特性公式<br>$$<br>i=\frac{dq}{dt}= \frac{d(cu)}{dt}= C \frac{du}{dt}<br>$$<br>移项得到<br>$$<br>du = \frac{idt}{C}<br>$$<br>两端同时积分<br>$$<br>u = \frac{1}{C} \int idt<br>$$<br>n个电容串联，电压相加，则<br>$$<br>u_1+u_2+…+u_n=\frac{1}{C_1} \int idt + \frac{1}{C_2} \int idt + … + \frac{1}{C_n} \int idt<br>$$<br>因为电流相同，则<br>$$<br>u_1+u_2+…+u_n=(\frac{1}{C_1} + \frac{1}{C_2} + … + \frac{1}{C_n}) \int idt<br>$$<br>通过和单个电容的伏安特性方程来比较，发现多个电容串联的等效电容就是<strong>多个电容的倒数之和</strong>，类似于电阻的并联</p><h2 id="并联"><a href="#并联" class="headerlink" title="并联"></a>并联</h2><p>根据<strong>并联电压相等，电流相加</strong>的原则，推导电容的并联等效公式</p><p>根据电容伏安特性公式<br>$$<br>i=\frac{dq}{dt}= \frac{d(cu)}{dt}= C \frac{du}{dt}<br>$$<br>推导n个电容并联<br>$$<br>i_1+i_2+…+i_n= C_1 \frac{du}{dt} + C_2 \frac{du}{dt} + … + C_n \frac{du}{dt}<br>$$<br>因为电压相等，则<br>$$<br>i_1+i_2+…+i_n= (C_1 + C_1 + … + C_n) \frac{du}{dt}<br>$$<br>推导出多个电容并联的等效电容就是<strong>多个电容之和</strong>，类似于电阻的串联</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653692&amp;cid=1005912483" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653692&amp;cid=1005912483</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AE%B9%E5%99%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AE%B9%E5%99%A8</a></li><li><a href="https://baike.baidu.com/item/%E7%94%B5%E5%AE%B9/146658#viewPageContent" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%94%B5%E5%AE%B9/146658#viewPageContent</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路元器件之电感器</title>
      <link href="/2018/11/24/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E6%84%9F%E5%99%A8/"/>
      <url>/2018/11/24/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E6%84%9F%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="电感器的组成"><a href="#电感器的组成" class="headerlink" title="电感器的组成"></a>电感器的组成</h1><p>电感器本质上就是一个绕组，绕组是指具有规定功能的一组线圈。</p><h1 id="电感器工作原理"><a href="#电感器工作原理" class="headerlink" title="电感器工作原理"></a>电感器工作原理</h1><p>而电感中流过交变电流，产生的磁场就是交变磁场，变化的磁场产生电场，线圈上就有感应电动势，产生感应电流。</p><p>根据<a href="https://baike.baidu.com/item/%E6%B3%95%E6%8B%89%E7%AC%AC%E7%94%B5%E7%A3%81%E6%84%9F%E5%BA%94%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">法拉第电磁感应定律</a>—磁生电来分析，变化的磁力线在线圈两端会产生感应<a href="https://baike.baidu.com/item/%E7%94%B5%E5%8A%BF" target="_blank" rel="noopener">电势</a>，此感应电势相当于一个“新电源”。</p><p>电流的变化分为两种情况：</p><ul><li>电流变大时：磁场变强，磁场变化的方向与原磁场方向相同。根据左手定则，产生的感应电流与原电流方向相反，电感电流减小；</li><li>电流变小时：磁场变弱，磁场变化的方向与原磁场方向相反。根据左手定则，产生的感应电流与原电流方向相同，电感电流变大。</li></ul><p><strong>可以从中看出，无论电流是变大还是变小，感应电流都和电流的变化趋势相反，在抗拒电流的变化。</strong></p><p>以上就是楞次定律，最终效果就是电感会阻碍流过的电流产生变化，就是电感对交变电流呈高阻抗。同样的电感，电流变化率越高，产生的感应电流越大，那么电感呈现的阻抗就越高；如果同样的电流变化率，不同的电感，如果产生的感应电流越大，那么电感呈现的阻抗就越高。</p><p>所以，电感的阻抗于两个因素有关：一是频率；二是电感的固有属性，也就电感的值，也称为电感。</p><h1 id="电感"><a href="#电感" class="headerlink" title="电感"></a>电感</h1><p>电感的值描述了一个电感器本身的感抗性质。描述的是通过一定交变电流的情况下，它对于电流的抵抗强度。</p><p>电感的单位为 <strong>亨利（H）</strong> ，符号为 <strong>L</strong> 。</p><p>电感是一个比值单位。他是通过电感的伏安特性计算得到。类似情况还有：电阻是通过电阻的伏安特性和欧姆定律得到。</p><h1 id="韦安特性"><a href="#韦安特性" class="headerlink" title="韦安特性"></a>韦安特性</h1><p>电感周围会产生磁场，磁场强度的单位为 <strong>韦伯（Wb）</strong>，符号为 <strong>Ψ</strong>，读作 <strong>普塞</strong> ，他也叫 <strong>磁链</strong> ，或者 <strong>磁通量</strong>。</p><p>$Ψ = Li$</p><p>也就是说，电感固定的情况下，电流与磁通量成正比关系。</p><h1 id="伏安特性"><a href="#伏安特性" class="headerlink" title="伏安特性"></a>伏安特性</h1><p>根据电磁感应定律和楞次定律，当电压、电流的方向如下图所示，并且电流与磁通的参考方向遵循右螺旋法则时，端口电压u和感应电动势e的关系如下：</p><p>$u=-e=\frac{dΨ}{dt}$ ，又因为  $Ψ = Li$ ，所以 $u=-e=\frac{dΨ}{dt}=L \frac{di}{dt}$</p><h1 id="电感器的性质"><a href="#电感器的性质" class="headerlink" title="电感器的性质"></a>电感器的性质</h1><ul><li><p>从上面的伏安特性公式中可以看出：同一个电感器两端的电压，取决于一定时间内，电流（i）的变化率。</p></li><li><p>电流变化越快，电感两端的电压越大。即使此时此刻电流为0，电感两端也有可能有电压。</p><p>因为在电流变化到0的前一个瞬间，变化率仍然存在，电感器产生的电磁场也还存在，会在电感两端产生电势差。</p></li><li><p>当电感电流为恒定直流的时候，电感两端电压为0。此时电感视为短路。</p><p>因为恒定直流的时候，流过电感器的电流产生恒定不变的磁场。该磁场不变，根据楞次定律，将不会产生一个抵抗电流变化的电势差，而是产生一个恒定方向的磁场。根据这个原理，可以制造出电磁铁，电磁继电器。</p></li><li><p>若任意时刻电感电压为有限值，电流 i 不能跃变。</p><p>从数学角度上来理解上面的伏安特性公式，当 L 和 u 不变，那么当 dt 为一个常数时， di 也一定为另一个常数，表示 i 的变化是均匀连续的。</p></li></ul><h1 id="电感器的用途"><a href="#电感器的用途" class="headerlink" title="电感器的用途"></a>电感器的用途</h1><p>电感器在通入直流电的时候相当于短路，因此无阻抗作用。但是其磁场强度强，可以做电磁铁。</p><p>电感器在通入交流电时将会抵抗部分电流变化，可以作为滤波器，过滤电路中的部分交流分量。</p><h1 id="同名端"><a href="#同名端" class="headerlink" title="同名端"></a>同名端</h1><p>在对交变电流电路作分析的时候，两个电感器不同的绕向，产生的磁场方向可能会不一样，或者叠加增强，或者相互抵消。</p><p>当两个电感，电流同时从端子流入时，<strong>如果产生的磁通增强，则称流入端为同名端。</strong></p><p>我们得知了同名端之后，不需要知道电感线圈的实际绕向，也能正确分析电路的伏安关系。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/21835930" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21835930</a></li><li><a href="https://forum.mianbaoban.cn/topic/57210_1_1.html" target="_blank" rel="noopener">https://forum.mianbaoban.cn/topic/57210_1_1.html</a></li><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653689&amp;cid=1005912479" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653689&amp;cid=1005912479</a></li><li><a href="https://wenku.baidu.com/view/ce9d436f4afe04a1b171de50.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ce9d436f4afe04a1b171de50.html</a></li></ul><p># </p>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电与磁的关系</title>
      <link href="/2018/11/22/%E7%94%B5%E4%B8%8E%E7%A3%81%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
      <url>/2018/11/22/%E7%94%B5%E4%B8%8E%E7%A3%81%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在中学阶段研究的电路都是通过干电池作为电源组成的直流电路。而实际电路中还有交变电流流过。</p><p>我们会发现，某些<strong>纯电阻</strong>用电器，例如白炽灯，<strong>白炽灯的电路模型可以抽象成一个电阻</strong>，构成这个电阻的材料是钨丝。<strong>白炽灯无论通过交流电，还是直流电，都能发光发热，并且都能正常工作</strong>。</p><p>而某些电路元件，例如<strong>电容器</strong>，<strong>电感器</strong>。<strong>它们在流过直流电流和交变电流的时候，会产生不一样的现象</strong>。</p><p>下面我们就来谈就这些现象，以及产生这种现象的原因。</p><h1 id="电与磁"><a href="#电与磁" class="headerlink" title="电与磁"></a>电与磁</h1><p>首先需要了解</p><p><a href="https://www.zhihu.com/question/55815003" target="_blank" rel="noopener">https://www.zhihu.com/question/55815003</a></p><h1 id="线圈"><a href="#线圈" class="headerlink" title="线圈"></a>线圈</h1><p>电路中经常能看到一些由线圈组成的元器件。</p><p>例如：</p><ul><li>变压器</li><li>电感器</li><li>继电器</li><li>电磁铁</li></ul><p>线圈本质上就是将导线按照螺旋形状缠绕起来，部分线圈可能使用的是带有一定电阻的漆包线。</p><p>有的线圈的螺旋洞中间会插入一个铁芯，有的不会。</p><p>通常元器件应该都要对电路产生一定的影响。例如电阻会阻碍电流流过，使得电路上的电流量变小。电池会持续在正负极性两端提供电势差，产生电压，使得电路上两个点的电位不同。</p><p>为什么把导线按照螺旋状缠绕起来就能组成一种新的元器件呢？换句话说，通电的导线究竟含有什么性质，使得他按照螺旋状缠绕以后，会对电路产生一定影响？</p><p>下面我们就来研究这个问题。</p><h1 id="电生磁（奥斯特实验）"><a href="#电生磁（奥斯特实验）" class="headerlink" title="电生磁（奥斯特实验）"></a>电生磁（奥斯特实验）</h1><p>如果在直导线附近（导线需要南北放置），放置一枚小磁针，则当导线中有电流通过时，磁针将发生偏转。</p><h1 id="通恒定电流导线周围产生的磁场"><a href="#通恒定电流导线周围产生的磁场" class="headerlink" title="通恒定电流导线周围产生的磁场"></a>通恒定电流导线周围产生的磁场</h1><p>导线通入恒定电流，会在周围产生一个磁场。磁场的方向可以通过<strong>安培定则</strong>（<strong>右手螺旋定则</strong>）</p><h1 id="右手定则（安培定则）"><a href="#右手定则（安培定则）" class="headerlink" title="右手定则（安培定则）"></a>右手定则（安培定则）</h1><blockquote><p>安培定则是表示<a href="https://baike.baidu.com/item/%E7%94%B5%E6%B5%81/268192" target="_blank" rel="noopener">电流</a>和电流激发<a href="https://baike.baidu.com/item/%E7%A3%81%E5%9C%BA/63505" target="_blank" rel="noopener">磁场</a>的磁感线方向间关系的定则。</p><ul><li><p>通电直导线中的安培定则（安培定则一）：用右手握住通电直导线，让大拇指指向电流的方向，那么四指指向就是磁感线的环绕方向</p></li><li><p><a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%B5%E8%9E%BA%E7%BA%BF%E7%AE%A1/1081222" target="_blank" rel="noopener">通电螺线管</a>中的安培定则（安培定则二）：用右手握住通电螺线管，让四指指向电流的方向，那么大拇指所指的那一端是通电螺线管的N极。</p></li></ul></blockquote><img src="/2018/11/22/电与磁的关系/Right-hand-rule.png" title="安培定則，右手螺旋定則"><h1 id="磁生电"><a href="#磁生电" class="headerlink" title="磁生电"></a>磁生电</h1><p>将导体放在磁场中，做切割磁感线（由磁场N极通往S极的有向线）运动，会在导体两端产生电势差。将导体相连，会产生电流，这种电流叫做感应电流。</p><h1 id="电磁感应现象"><a href="#电磁感应现象" class="headerlink" title="电磁感应现象"></a>电磁感应现象</h1><blockquote><p><strong>电磁感应</strong>（<strong>英语：</strong>Electromagnetic induction），是指放在变化<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E9%80%9A%E9%87%8F" target="_blank" rel="noopener">磁通量</a>中的<a href="https://zh.wikipedia.org/wiki/%E5%B0%8E%E9%AB%94" target="_blank" rel="noopener">导体</a>，会产生<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%8A%A8%E5%8A%BF" target="_blank" rel="noopener">电动势</a>。此电动势称为<strong>感应电动势</strong>或<strong>感生电动势</strong>，若将此导体闭合成一回路，则该电动势会驱使<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90" target="_blank" rel="noopener">电子</a>流动，形成<strong>感应电流</strong>（<strong>感生电流</strong>）。</p></blockquote><blockquote><p>闭合回路在原磁场内产生的磁场阻碍原磁场磁通量发生变化的电流叫做感应电流。</p><p>是指放在变化磁通量中的导体闭合成一回路，则该电动势会驱使电子流动，形成感应电流（感生电流）。</p><p>通俗的讲，当闭合回路的一部份导体在磁场中作切割磁感线运动时，此闭合回路中的磁通量一定会发生变化，在闭合回路中就产生了感应电动势，从而产生了电流，这种电流称为感应电流。</p></blockquote><p>磁通量的变化是相对的。例如导体处于静止状态，磁场本身在不停的变化，那么通过导体的磁通量也就发生了变化。或者磁场本身不变，导体在磁场中做切割磁感线运动。</p><p>导体放在<strong>磁通量变化</strong>的场中，会产生<strong>感生电动势</strong>。如果用导线把这个导体闭合，将会形成<strong>感应电流</strong>。</p><h1 id="动生电动势"><a href="#动生电动势" class="headerlink" title="动生电动势"></a>动生电动势</h1><blockquote><p>导体以垂直于磁感线的方向在磁场中运动，在同时垂直于磁场和运动方向的两端产生的电动势，称为动生电动势。</p><p>动生电动势是由于导体中载流子在磁场中运动受到垂直于磁场和运动方向的<a href="https://zh.wikipedia.org/wiki/%E6%B4%9B%E4%BB%91%E5%85%B9%E5%8A%9B" target="_blank" rel="noopener">洛仑兹力</a>的作用，在导体内移动的结果。</p></blockquote><p>理解动生电动势的两端位置，关键是要建立三维立体坐标的概念。</p><p><strong>同时垂直于磁场和运动方向的两端产生的电动势</strong>，为<strong>动生电动势</strong>。</p><h1 id="楞次定律"><a href="#楞次定律" class="headerlink" title="楞次定律"></a>楞次定律</h1><blockquote><p>由于磁通量的改变而产生的感应电流，其方向为抗拒磁通量改变的方向。</p></blockquote><h1 id="磁场方向"><a href="#磁场方向" class="headerlink" title="磁场方向"></a>磁场方向</h1><p>N 到 S</p><h1 id="左手定则"><a href="#左手定则" class="headerlink" title="左手定则"></a>左手定则</h1><blockquote><p>左手定则，是英国电机工程师约翰.安布罗斯.弗莱明（JohnAmbroseFleming,1849~1945）提出的。1885年，弗莱明担任英国伦敦大学电机工程学教授，由于学生经常弄错磁场，电流和受力的方向。于是，他想用一个简单的方法帮助学生记忆。“左手定则”由此诞生了。</p></blockquote><p>左手定则是张开左手，让手心对着磁极N，让磁感线垂直穿过手心，大拇指与其余4指在同一<a href="http://www.baike.com/wiki/%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">平面</a>垂直，4根手指方向是电流方向，此时大拇指所指的方向就是该通电导体在磁场中的运动方向。发电机就是应用左手定则，还可以研究电导体在磁场中的运动方向。</p><h1 id="通变化电流导线周围产生的磁场"><a href="#通变化电流导线周围产生的磁场" class="headerlink" title="通变化电流导线周围产生的磁场"></a>通变化电流导线周围产生的磁场</h1><img src="/2018/11/22/电与磁的关系/coil.png" title="通变化电流导线周围产生的磁场"><p>给一个导线通入恒定电流，将会在导线周围产生磁场。根据楞次定律和右手定则，磁场方向为红色箭头所指的<strong>向左</strong>。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://baike.baidu.com/item/%E5%AE%89%E5%9F%B9%E5%AE%9A%E5%88%99/10784798?fromtitle=%E5%8F%B3%E6%89%8B%E8%9E%BA%E6%97%8B%E5%AE%9A%E5%88%99&amp;fromid=2948936" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AE%89%E5%9F%B9%E5%AE%9A%E5%88%99/10784798?fromtitle=%E5%8F%B3%E6%89%8B%E8%9E%BA%E6%97%8B%E5%AE%9A%E5%88%99&amp;fromid=2948936</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%A5%9E%E6%AC%A1%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%A5%9E%E6%AC%A1%E5%AE%9A%E5%BE%8B</a></li><li><a href="https://zhuanlan.zhihu.com/p/29304601" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29304601</a></li><li><a href="https://baike.baidu.com/item/%E7%94%B5%E6%84%9F/98570" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%94%B5%E6%84%9F/98570</a></li><li><a href="https://baike.baidu.com/item/%E6%84%9F%E5%BA%94%E7%94%B5%E6%B5%81" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%84%9F%E5%BA%94%E7%94%B5%E6%B5%81</a></li><li><a href="https://www.zhihu.com/question/28517426" target="_blank" rel="noopener">https://www.zhihu.com/question/28517426</a></li><li><a href="https://www.zhihu.com/question/38670547" target="_blank" rel="noopener">https://www.zhihu.com/question/38670547</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路元器件之电阻器</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E9%98%BB%E5%99%A8/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%85%83%E5%99%A8%E4%BB%B6%E4%B9%8B%E7%94%B5%E9%98%BB%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对电流有阻碍作用的电路元件。</p><p>单位：欧姆（Ω Ohm）</p><h1 id="欧姆定律"><a href="#欧姆定律" class="headerlink" title="欧姆定律"></a>欧姆定律</h1><p>$i = \frac{u}{R}$</p><p>对于线性二端电阻，其端口电压与电流之间成正比关系</p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>将流过相同电流的两个端子称为一个端口（port）</p><h1 id="电导"><a href="#电导" class="headerlink" title="电导"></a>电导</h1><p>电阻的倒数，单位：西门子（S）</p><h1 id="非线性电阻"><a href="#非线性电阻" class="headerlink" title="非线性电阻"></a>非线性电阻</h1><p>伏安特性曲线不是过 u-i 平面原点的直线</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653687&amp;cid=1005912477" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653687&amp;cid=1005912477</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路基本物理量之电功率和电能</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E5%8A%9F%E7%8E%87%E5%92%8C%E7%94%B5%E8%83%BD/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E5%8A%9F%E7%8E%87%E5%92%8C%E7%94%B5%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="电功率"><a href="#电功率" class="headerlink" title="电功率"></a>电功率</h1><p>衡量电能转换或者传输速率的物理量</p><h1 id="电功率的定义"><a href="#电功率的定义" class="headerlink" title="电功率的定义"></a>电功率的定义</h1><p>设 dt 时间内传输的电能为 dw。</p><p>$p = \frac{dW}{dt}$</p><h1 id="电能"><a href="#电能" class="headerlink" title="电能"></a>电能</h1><p>t0 到 t 时间内，电路吸收或者发出的能量</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653677&amp;cid=1005912461" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653677&amp;cid=1005912461</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路基本物理量之电位和电动势</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E4%BD%8D%E5%92%8C%E7%94%B5%E5%8A%A8%E5%8A%BF/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E4%BD%8D%E5%92%8C%E7%94%B5%E5%8A%A8%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="电位"><a href="#电位" class="headerlink" title="电位"></a>电位</h1><p>任选一个点 p 作为参考点，电路中某点与参考点之间的电压称为该点的电位，用φ（fai）表示。</p><p>两点之间的电压，等于两点之间的电位差。</p><h1 id="电动势"><a href="#电动势" class="headerlink" title="电动势"></a>电动势</h1><p>单位正电荷在局外电场和感应电场的作用下从 a 点沿路线 l 移动到 b 点这些力所做的功称为从 a 到 b 沿路线 l 的电动势。</p><p>电动势是外力做功的结果，而不是电场力。所以方向是低电位指向高电位，它与电压的实际方向相反。</p><p>电动势本质上是外力抵抗电场力做功的结果。</p><p>$W(t) = \int_a^b p(t)dt $</p><p>单位：焦耳（J）</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653676&amp;cid=1005912459" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653676&amp;cid=1005912459</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路基本物理量之电压</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E5%8E%8B/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E5%8E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="电场"><a href="#电场" class="headerlink" title="电场"></a>电场</h1><p>在空间中，放置一个正电荷和一个负电荷，正负电荷之间则会产生电场。</p><p>电场方向为从正电荷到负电荷。</p><p>电场中如果放置一个电荷，将会被产生电场的电荷（位于电场的两端）作用产生库仑力。库仑力具体的大小需要通过库仑定律求得。</p><p>将这个电荷在电场中移动，需要一个力来做功。</p><h1 id="电压的定义"><a href="#电压的定义" class="headerlink" title="电压的定义"></a>电压的定义</h1><p>$u_{ab} = \int_a^b E<em>d</em>l$</p><p>$W = E <em> q </em> d <em> l = F </em> d * l$</p><p>指的是单位正电荷在电场力的作用下，由 a 点沿着路线 l 移动到 b 点所做的功，为 a  b 两点间的电压。</p><p>$u = \frac{dW}{dq}$</p><p>单位：伏特（V）</p><h1 id="电压的方向"><a href="#电压的方向" class="headerlink" title="电压的方向"></a>电压的方向</h1><p>电压的方向是相对的。</p><p>正极为高电位，负极为低电位。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653675&amp;cid=1005912457" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653675&amp;cid=1005912457</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路基本物理量之电流</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E6%B5%81/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E7%89%A9%E7%90%86%E9%87%8F%E4%B9%8B%E7%94%B5%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="电流的定义"><a href="#电流的定义" class="headerlink" title="电流的定义"></a>电流的定义</h1><p>单位时间段 dt 内，通过某界面的电荷量的代数和为 dq。<br>则电流为 dq/dt 。</p><p>单位：安培（A）</p><p>符号：I</p><h1 id="电流的方向"><a href="#电流的方向" class="headerlink" title="电流的方向"></a>电流的方向</h1><p>电流的方向是相对的。</p><p>我们首先需要任意定义一个参考方向。所有与参考方向相反的电流都是负的。（这里虽然说参考方向可以任意定义，但是还是需要根据实际情况，选择最方便解题的参考方向。）</p><p>Iab表示从a流入，从b流出的电流。a也是参考方向的正极，b为参考方向的负极。</p><h1 id="电流分类"><a href="#电流分类" class="headerlink" title="电流分类"></a>电流分类</h1><h2 id="直流（DC-Direct-Current）"><a href="#直流（DC-Direct-Current）" class="headerlink" title="直流（DC Direct Current）"></a>直流（DC Direct Current）</h2><p>direct adj. 直接的</p><p>i的量值和方向不随时间变化的电流，用 I 表示。</p><h2 id="交流（AC-Alternating-Current）"><a href="#交流（AC-Alternating-Current）" class="headerlink" title="交流（AC Alternating Current）"></a>交流（AC Alternating Current）</h2><p>alternate adj. 交替的</p><p>i的量值和方向随时间周期变化切且平均值为0的电流称为交流，用 i(t) 表示。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653674&amp;cid=1005912455" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653674&amp;cid=1005912455</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电路基本概念与分类</title>
      <link href="/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
      <url>/2018/11/22/%E7%94%B5%E8%B7%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="电路的定义"><a href="#电路的定义" class="headerlink" title="电路的定义"></a>电路的定义</h1><p>有电器件互联而成的电流的通路。</p><h1 id="组成电路的电器件"><a href="#组成电路的电器件" class="headerlink" title="组成电路的电器件"></a>组成电路的电器件</h1><ul><li>电阻器</li><li>电容器</li><li>电感器（线圈）</li><li>电源（激励）</li><li>晶体管</li></ul><h1 id="各种电器件介绍"><a href="#各种电器件介绍" class="headerlink" title="各种电器件介绍"></a>各种电器件介绍</h1><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>提供电能和电信号的装置</p><h2 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h2><p>吸收电能或电信号的装置</p><h2 id="中间环节"><a href="#中间环节" class="headerlink" title="中间环节"></a>中间环节</h2><p>连接电源和负债，并对电路的工作状态进行控制。<br>例如传输线，继电器，变压器。</p><h1 id="电路的作用"><a href="#电路的作用" class="headerlink" title="电路的作用"></a>电路的作用</h1><p>实现电能或者电信号的传输，处理和存储</p><h1 id="电路模型和理想化电路"><a href="#电路模型和理想化电路" class="headerlink" title="电路模型和理想化电路"></a>电路模型和理想化电路</h1><p>由于物理环境的影响，实际的电路有许多无法计算和预料的变量，而这些变量对于电路影响较小。在理想化电路中，我们把这些影响较小的变量排除，得到理想化电路。</p><p>例如实际导线是有电阻的，但是该电阻较小，在一定场景下对我们研究的问题没有太大影响，直接忽略。</p><p>但是某些场景下，例如研究电源内阻问题的时候，内阻会对我们的问题产生影响，我们不能把它忽略。</p><p>所以，理想化电路究竟该把哪些变量影响剔除，也需要和实际问题相结合来判断。</p><h1 id="电路分类"><a href="#电路分类" class="headerlink" title="电路分类"></a>电路分类</h1><p>任何分类都需要有一个标准，因此下面按照不同的标准可以将电路分为好几类。</p><h2 id="线性电路-amp-非线性电路"><a href="#线性电路-amp-非线性电路" class="headerlink" title="线性电路&amp;非线性电路"></a>线性电路&amp;非线性电路</h2><h3 id="线性电路"><a href="#线性电路" class="headerlink" title="线性电路"></a>线性电路</h3><p>全部由线性元件构成的电路（线性电阻）</p><h3 id="非线性电路"><a href="#非线性电路" class="headerlink" title="非线性电路"></a>非线性电路</h3><p>具有非线性电路的元件（二极管）</p><h2 id="时变电路-amp-非时变电路"><a href="#时变电路-amp-非时变电路" class="headerlink" title="时变电路&amp;非时变电路"></a>时变电路&amp;非时变电路</h2><h3 id="时变电路"><a href="#时变电路" class="headerlink" title="时变电路"></a>时变电路</h3><p>具有时变元件的电路</p><h3 id="非时变电路"><a href="#非时变电路" class="headerlink" title="非时变电路"></a>非时变电路</h3><p>全部由非时变元件构成的电路</p><h2 id="集中参数电路-amp-分布参数电路"><a href="#集中参数电路-amp-分布参数电路" class="headerlink" title="集中参数电路&amp;分布参数电路"></a>集中参数电路&amp;分布参数电路</h2><h3 id="集中参数元件"><a href="#集中参数元件" class="headerlink" title="集中参数元件"></a>集中参数元件</h3><p>当元件的几何尺寸远小于电磁量工作频率所对应的电磁波波长，而无需考虑电磁量的空间分布时，这种元件称为集中参数元件。</p><h3 id="集中参数电路"><a href="#集中参数电路" class="headerlink" title="集中参数电路"></a>集中参数电路</h3><p>全部由集中参数元件构成的电路</p><h3 id="分布参数电路"><a href="#分布参数电路" class="headerlink" title="分布参数电路"></a>分布参数电路</h3><p>具有分布参数元件构成的电路</p><p><strong>注意具有和全部的区别。全部的约束性更强。线性电路要求全部都是线性元件。但是只要线性电路中包含一个非线性元件，那么整个电路就是非线性电路。线性电路的约束性更强。</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653672&amp;cid=1005912451" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653672&amp;cid=1005912451</a></p></li><li><p><a href="https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653673&amp;cid=1005912453" target="_blank" rel="noopener">https://www.icourse163.org/learn/HIT-1001998008?tid=1003308024#/learn/content?type=detail&amp;id=1004653673&amp;cid=1005912453</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> electric </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Hexo快速构建一个博客网站</title>
      <link href="/2018/11/22/%E4%BD%BF%E7%94%A8Hexo%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2018/11/22/%E4%BD%BF%E7%94%A8Hexo%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="本地构建"><a href="#本地构建" class="headerlink" title="本地构建"></a>本地构建</h1><p>首先安装好node.js，然后跟着我敲命令就对了。</p><p>我以macOS为例，Windows用户推荐使用bash shell</p><ul><li><code>npm install -g hexo-cli # 安裝hexo命令行工具，安装之后就可以直接使用hexo命令了。因为node自动设置了PATH环境变量，你输入hexo命令，操作系统会自动在node包目录下寻找到对应的node.js脚本执行</code></li><li><code>hexo init blog # 在当前目录下创建一个名为blog的目录，并且把blog目录作为整个博客站点的web目录，然后初在该目录下始化生成npm的依赖关系脚本</code></li><li><code>cd blog # 进入blog目录，这里cd是change directory的意思，可不是“给你一张过去的CD”</code></li><li><code>npm install # 根据之前生成的npm依赖关系声明文件package.json，自动下载并且安装对应的依赖库文件。这些依赖库文件构成了hexo的核心程序代码。（据我测试，在新版本的hexo-cli下，使用hexo init blog命令其实是会自动下载并且安装好hexo的相关依赖和核心程序代码，所以这一步在新版本上是否有必要是指的怀疑的。不过为了保险起见，重复install一次也没什么影响。）</code></li><li><code>hexo generate # 执行后，自动根据配置文件和已有的博客内容构建public目录。</code> </li><li><code>hexo server # 执行后，会自动在本地的4000端口上开启一个web服务器，请在浏览器地址栏输入 http://127.0.0.1:4000/ 访问，如果成功显示博客站点，则表示无问题。</code> </li></ul><p>安装好一户的目录结构如下</p><pre><code>masaweideMacBook-Pro:blog changwei$ ls -altotal 320drwxr-xr-x   13 changwei  staff     416 11 22 00:26 .drwxr-xr-x    8 changwei  staff     256 11 22 00:15 ..drwxr-xr-x    9 changwei  staff     288 11 22 00:26 .deploy_git-rw-r--r--    1 changwei  staff      65 11 22 00:15 .gitignore-rw-r--r--@   1 changwei  staff    1954 11 22 00:31 _config.yml-rw-r--r--    1 changwei  staff     174 11 22 00:42 db.jsondrwxr-xr-x  303 changwei  staff    9696 11 22 00:17 node_modules-rw-r--r--    1 changwei  staff  146130 11 22 00:17 package-lock.json-rw-r--r--    1 changwei  staff     482 11 22 00:19 package.jsondrwxr-xr-x    8 changwei  staff     256 11 22 00:26 publicdrwxr-xr-x    5 changwei  staff     160 11 22 00:15 scaffoldsdrwxr-xr-x    3 changwei  staff      96 11 22 00:15 sourcedrwxr-xr-x    3 changwei  staff      96 11 22 00:15 themes</code></pre><ul><li>_config.yml yml格式。配置文件。</li><li>package.json json格式。hexo程序代码依赖关系声明文件，被npm所用，除非需要自行安装或者修改插件，否则一般不要随意修改。</li><li>scaffolds.folder 文件夹。里面有数个md文件，定义了每次新建一个文章的时候，默认包含的内容。</li><li>source.folder 文件夹。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li><li>themes.folder 文件夹。存储博客主题。可以认为是游戏中的skin，皮肤，或者界面样式。内含数个文件夹，每个文件夹为一个主题。文件夹名字为主题名字。除非需要手动修改主题，否则一般情况下不要随意修改。</li><li>public.folder 文件夹。整个博客站点对外发布的目录。整个目录就是web目录，在这个目录下的文件都会被发布到web站点上。都可以被所有用户访问。一般情况下，他会通过hexo内建的脚本自动生成，不需要我们手动修改。</li></ul><h1 id="将该博客站点发布到GitHub-Pages"><a href="#将该博客站点发布到GitHub-Pages" class="headerlink" title="将该博客站点发布到GitHub Pages"></a>将该博客站点发布到GitHub Pages</h1><p>安装git客户端</p><ul><li><code>git config --global user.name &quot;cw1997&quot; # 设置git的全局用户名，为你github的用户名，请根据你的信息修改，不要照抄我的。</code></li><li><code>git config --global user.email &quot;867597730@qq.com&quot; # 设置git的全局email为你github的注册邮箱，请根据你的信息修改，不要照抄我的。</code></li><li><p><code>npm install hexo-deployer-git --save # 保证当前目录为blog（使用pwd检查），然后执行该命令安装hexo发布到git的一个依赖包。</code></p></li><li><p>在web界面登陆你的github账号，创建一个名字为 <code>{你的github用户名}.github.io.git</code> 的仓库</p></li></ul><p>修改_config.yml，将 deploy 配置项修改为：</p><pre><code>deploy:  type: git  repo: https://github.com/cw1997/cw1997.github.io.git  branch: master</code></pre><p>其中repo后面记得修改为你自己的github用户名，不要照抄我的 “cw1997”</p><ul><li><code>hexo generate # 执行构建操作，构建public目录</code></li><li><code>hexo deploy # 执行发布操作，会提示输入用户名密码，记得输入你的github用户名和github登陆密码</code></li><li>打开 <code>{你的github用户名}.github.io.git</code> 欣赏的博客</li></ul><h1 id="给博客设置一个独立域名"><a href="#给博客设置一个独立域名" class="headerlink" title="给博客设置一个独立域名"></a>给博客设置一个独立域名</h1><ul><li>首先购买一个域名，并且知道如何访问域名控制面板进行域名解析操作</li><li>进入你的github仓库设置页面，URL为 <code>https://github.com/{你的github用户名}/{你的github用户名}.github.io/settings</code></li><li>在下面找到  <code>Custom domain</code> ，将他设置为你自己的网站域名之后点 SAVE 按钮保存</li><li>进入域名解析面板，新增一条解析记录，类型为 CNAME ，记录名字为你想要的博客的二级域名，例如你想要<code>www.changwei.me</code>访问，那么记录名字就是<code>www</code>。记录值为<code>{你的github用户名}.github.io.git</code>。然后保存即可，等待一段时间，待DNS解析生效后即可使用自己的域名访问了。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/index.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26625249</a></li><li><a href="https://haoshuai6.github.io/2016-11-25-Hexo-github-cname.html" target="_blank" rel="noopener">https://haoshuai6.github.io/2016-11-25-Hexo-github-cname.html</a></li><li><a href="https://blog.amaork.me/2017/10/28/Hexo-%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/" target="_blank" rel="noopener">https://blog.amaork.me/2017/10/28/Hexo-%E7%BB%91%E5%AE%9A%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/22/hello-world/"/>
      <url>/2018/11/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
